{"version":3,"file":"modelaudiokaraoke.min.js","sources":["../src/modelaudiokaraoke.js"],"sourcesContent":["define(['jquery', 'core/log', 'mod_readaloud/definitions'], function($, log, def) {\n  \"use strict\"; // jshint ;_;\n  /*\n  This file runs preview and shadow and L-and-R modes, highlighting text as the player reaches it.\n   */\n\n  log.debug('Model Audio Karaoke: initialising');\n\n  return {\n    controls: {},\n    breaks: [],\n    endwordnumber: 0,\n    currentstartbreak: false,\n    modeling: false,\n\n    //class definitions\n    cd: {\n      audioplayerclass: def.audioplayerclass,\n      wordplayerclass: def.wordplayerclass,\n      wordclass: def.wordclass,\n      spaceclass: def.spaceclass,\n      endspaceclass: def.endspaceclass,\n      passagecontainer: def.passagecontainer,\n      activesentence: def.activesentence,\n      stopbutton: 'mod_readaloud_button_stop',\n      playbutton: 'mod_readaloud_button_play'\n    },\n\n    //init the module\n    init: function(opts) {\n      if (opts.breaks) {\n        var breaks = JSON.parse(opts.breaks);\n        this.set_breaks(breaks);\n      }\n      if (opts.modeling) {\n        this.modeling = true;\n      }\n      if (opts.audioplayerclass) {\n        this.cd.audioplayerclass = opts.audioplayerclass;\n      }\n\n      //register the controls\n      this.register_controls();\n\n      //register the end word number\n      this.endwordnumber = this.controls.eachword.length;\n\n      //register the events\n      this.register_events();\n    },\n\n    set_breaks: function(breaks) {\n      this.breaks = breaks;\n      this.sort_breaks();\n      this.number_breaks();\n    },\n\n    sort_breaks: function() {\n      this.breaks.sort(function(a, b) {\n        return a.audiotime - b.audiotime\n      });\n    },\n\n    number_breaks: function(){\n      var that=this;\n        for (var i = 0; i < that.breaks.length; i++) {\n           that.breaks[i].breaknumber=i+1;\n        }\n    },\n\n    pause_audio: function() {\n      this.controls.audioplayer[0].pause();\n    },\n\n    play_audio: function() {\n      this.controls.audioplayer[0].play();\n    },\n\n    get_audio_time() {\n      return this.controls.audioplayer[0].currentTime;\n    },\n\n    set_audio_time(newtime) {\n      this.controls.audioplayer[0].currentTime=newtime;\n    },\n\n    fetch_audio_url: function() {\n      return this.controls.audioplayer.attr('src');\n    },\n\n    //load all the controls so we do not have to do it later\n    register_controls: function() {\n      this.controls.audioplayer = $('#' + this.cd.audioplayerclass);\n      this.controls.eachword = $('.' + this.cd.wordclass);\n      this.controls.eachspace = $('.' + this.cd.spaceclass);\n      this.controls.eachwordorspace = $('.' + this.cd.spaceclass + ',.' + this.cd.wordclass);\n      this.controls.passagecontainer = $(\".\" + this.cd.passagecontainer);\n      this.controls.stopbutton = $('#' + this.cd.stopbutton);\n      this.controls.playbutton = $('#' + this.cd.playbutton);\n    },\n\n    //attach the various event handlers we need\n    register_events: function() {\n      var that = this;\n\n      // Get the audio element\n      var aplayer = this.controls.audioplayer[0];\n\n      this.controls.playbutton.on('click', function() {\n        aplayer.play();\n      });\n\n      this.controls.stopbutton.on('click', function() {\n        aplayer.pause();\n        aplayer.currentTime=0;\n      });\n\n      //if we are not modeling we want to jump to the clicked location\n      //if we are modeling the meaning of a click is to place a marker, so we do not want to jump\n      if (!this.modeling) {\n        this.controls.eachwordorspace.on('click', function() {\n          var wordnumber = parseInt($(this).attr('data-wordnumber'));\n          var nearest_start_break = false;\n          for (var i = 0; i < that.breaks.length; i++) {\n            if (that.breaks[i].wordnumber < wordnumber) {\n              nearest_start_break = that.breaks[i];\n            } else {\n              //exit the loop;\n              break;\n            }\n          }\n          if (!nearest_start_break) {\n            //start from beginning OR do nothing\n          } else {\n            aplayer.pause();\n            aplayer.currentTime = nearest_start_break.audiotime;\n            aplayer.play();\n          }\n        }); //end of eachwordorspace\n      } //end of if not modeling\n\n      var timeupdate = function() {\n        var currentTime = aplayer.currentTime;\n        var startbreak = false;\n        var nextbreak = false;\n        for (var i = 0; i < that.breaks.length; i++) {\n\n          //if this is the last marked break (ie flow till end)\n          if (currentTime >= that.breaks[i].audiotime && i + 1 === that.breaks.length) {\n            startbreak = that.breaks[i];\n            nextbreak = {\n              wordnumber: that.endwordnumber + 1,\n              audiotime: 0\n            };\n            //if its just between two breaks (yay)\n          } else if (currentTime >= that.breaks[i].audiotime && currentTime < that.breaks[i + 1].audiotime) {\n            startbreak = that.breaks[i];\n            nextbreak = that.breaks[i + 1];\n            break;\n            //this is the first section\n          } else if (i === 0 && currentTime < that.breaks[i].audiotime && currentTime > 0) {\n            startbreak = {\n              wordnumber: 0,\n              audiotime: 0,\n              breaknumber: 0,\n            };\n            nextbreak = that.breaks[i];\n\n          }\n        }\n        //if the current break changed since last time, we go in here\n        // (on first time through we want to flag  \"changed\" so that is why a false current startbreak goes to \"changed\"\n        //in the special case that we reached the end of the passage we need to raise the eevent\n        var islastbreak = aplayer.ended && nextbreak.audiotime===0;\n        if (that.currentstartbreak === false || startbreak.wordnumber !== that.currentstartbreak.wordnumber || islastbreak) {\n          var finishedsentence = $('.' + that.cd.activesentence).text();\n          that.previousstartbreak = that.currentstartbreak;\n          that.currentstartbreak = startbreak;\n          that.controls.eachword.removeClass(that.cd.activesentence);\n          that.controls.eachspace.removeClass(that.cd.activesentence);\n          if (startbreak !== false && nextbreak !== false) {\n            for (var thewordnumber = startbreak.wordnumber + 1; thewordnumber <= nextbreak.wordnumber; thewordnumber++) {\n              $('#' + that.cd.spaceclass + '_' + thewordnumber).addClass((that.cd.activesentence));\n              $('#' + that.cd.wordclass + '_' + thewordnumber).addClass((that.cd.activesentence));\n            }\n          }\n          that.on_reach_audio_break(finishedsentence, that.previousstartbreak, that.currentstartbreak, that.breaks);\n        }\n      };\n\n      //Player events (onended, onpause, ontimeupdate)\n      var ended = function() {\n        that.controls.eachword.removeClass(that.cd.activesentence);\n        that.controls.eachspace.removeClass(that.cd.activesentence);\n        that.currentstartbreak = false;\n      };\n\n\n      aplayer.onended = ended;\n      aplayer.onpause = ended;\n      aplayer.ontimeupdate = timeupdate;\n    }, //end of register events\n\n\n    on_reach_audio_break: function(sentence, oldbreak, newbreak, breaks) {\n      log.debug(sentence);\n      log.debug(oldbreak);\n      log.debug(newbreak);\n    }\n\n  }; //end of return value\n});"],"names":["define","$","log","def","debug","controls","breaks","endwordnumber","currentstartbreak","modeling","cd","audioplayerclass","wordplayerclass","wordclass","spaceclass","endspaceclass","passagecontainer","activesentence","stopbutton","playbutton","init","opts","JSON","parse","set_breaks","register_controls","this","eachword","length","register_events","sort_breaks","number_breaks","sort","a","b","audiotime","i","breaknumber","pause_audio","audioplayer","pause","play_audio","play","get_audio_time","currentTime","set_audio_time","newtime","fetch_audio_url","attr","eachspace","eachwordorspace","that","aplayer","on","wordnumber","parseInt","nearest_start_break","ended","removeClass","onended","onpause","ontimeupdate","startbreak","nextbreak","islastbreak","finishedsentence","text","previousstartbreak","thewordnumber","addClass","on_reach_audio_break","sentence","oldbreak","newbreak"],"mappings":"AAAAA,yCAAO,CAAC,SAAU,WAAY,8BAA8B,SAASC,EAAGC,IAAKC,YAM3ED,IAAIE,MAAM,qCAEH,CACLC,SAAU,GACVC,OAAQ,GACRC,cAAe,EACfC,mBAAmB,EACnBC,UAAU,EAGVC,GAAI,CACFC,iBAAkBR,IAAIQ,iBACtBC,gBAAiBT,IAAIS,gBACrBC,UAAWV,IAAIU,UACfC,WAAYX,IAAIW,WAChBC,cAAeZ,IAAIY,cACnBC,iBAAkBb,IAAIa,iBACtBC,eAAgBd,IAAIc,eACpBC,WAAY,4BACZC,WAAY,6BAIdC,KAAM,SAASC,SACTA,KAAKf,OAAQ,KACXA,OAASgB,KAAKC,MAAMF,KAAKf,aACxBkB,WAAWlB,QAEde,KAAKZ,gBACFA,UAAW,GAEdY,KAAKV,wBACFD,GAAGC,iBAAmBU,KAAKV,uBAI7Bc,yBAGAlB,cAAgBmB,KAAKrB,SAASsB,SAASC,YAGvCC,mBAGPL,WAAY,SAASlB,aACdA,OAASA,YACTwB,mBACAC,iBAGPD,YAAa,gBACNxB,OAAO0B,MAAK,SAASC,EAAGC,UACpBD,EAAEE,UAAYD,EAAEC,cAI3BJ,cAAe,mBAEFK,EAAI,EAAGA,EADTV,KACkBpB,OAAOsB,OAAQQ,IADjCV,KAECpB,OAAO8B,GAAGC,YAAYD,EAAE,GAIpCE,YAAa,gBACNjC,SAASkC,YAAY,GAAGC,SAG/BC,WAAY,gBACLpC,SAASkC,YAAY,GAAGG,QAG/BC,iCACSjB,KAAKrB,SAASkC,YAAY,GAAGK,aAGtCC,wBAAeC,cACRzC,SAASkC,YAAY,GAAGK,YAAYE,SAG3CC,gBAAiB,kBACRrB,KAAKrB,SAASkC,YAAYS,KAAK,QAIxCvB,kBAAmB,gBACZpB,SAASkC,YAActC,EAAE,IAAMyB,KAAKhB,GAAGC,uBACvCN,SAASsB,SAAW1B,EAAE,IAAMyB,KAAKhB,GAAGG,gBACpCR,SAAS4C,UAAYhD,EAAE,IAAMyB,KAAKhB,GAAGI,iBACrCT,SAAS6C,gBAAkBjD,EAAE,IAAMyB,KAAKhB,GAAGI,WAAa,KAAOY,KAAKhB,GAAGG,gBACvER,SAASW,iBAAmBf,EAAE,IAAMyB,KAAKhB,GAAGM,uBAC5CX,SAASa,WAAajB,EAAE,IAAMyB,KAAKhB,GAAGQ,iBACtCb,SAASc,WAAalB,EAAE,IAAMyB,KAAKhB,GAAGS,aAI7CU,gBAAiB,eACXsB,KAAOzB,KAGP0B,QAAU1B,KAAKrB,SAASkC,YAAY,QAEnClC,SAASc,WAAWkC,GAAG,SAAS,WACnCD,QAAQV,eAGLrC,SAASa,WAAWmC,GAAG,SAAS,WACnCD,QAAQZ,QACRY,QAAQR,YAAY,KAKjBlB,KAAKjB,eACHJ,SAAS6C,gBAAgBG,GAAG,SAAS,mBACpCC,WAAaC,SAAStD,EAAEyB,MAAMsB,KAAK,oBACnCQ,qBAAsB,EACjBpB,EAAI,EAAGA,EAAIe,KAAK7C,OAAOsB,QAC1BuB,KAAK7C,OAAO8B,GAAGkB,WAAaA,WADMlB,IAEpCoB,oBAAsBL,KAAK7C,OAAO8B,GAMjCoB,sBAGHJ,QAAQZ,QACRY,QAAQR,YAAcY,oBAAoBrB,UAC1CiB,QAAQV,eAuDVe,MAAQ,WACVN,KAAK9C,SAASsB,SAAS+B,YAAYP,KAAKzC,GAAGO,gBAC3CkC,KAAK9C,SAAS4C,UAAUS,YAAYP,KAAKzC,GAAGO,gBAC5CkC,KAAK3C,mBAAoB,GAI3B4C,QAAQO,QAAUF,MAClBL,QAAQQ,QAAUH,MAClBL,QAAQS,aA3DS,mBACXjB,YAAcQ,QAAQR,YACtBkB,YAAa,EACbC,WAAY,EACP3B,EAAI,EAAGA,EAAIe,KAAK7C,OAAOsB,OAAQQ,OAGlCQ,aAAeO,KAAK7C,OAAO8B,GAAGD,WAAaC,EAAI,IAAMe,KAAK7C,OAAOsB,OACnEkC,WAAaX,KAAK7C,OAAO8B,GACzB2B,UAAY,CACVT,WAAYH,KAAK5C,cAAgB,EACjC4B,UAAW,OAGR,CAAA,GAAIS,aAAeO,KAAK7C,OAAO8B,GAAGD,WAAaS,YAAcO,KAAK7C,OAAO8B,EAAI,GAAGD,UAAW,CAChG2B,WAAaX,KAAK7C,OAAO8B,GACzB2B,UAAYZ,KAAK7C,OAAO8B,EAAI,SAGb,IAANA,GAAWQ,YAAcO,KAAK7C,OAAO8B,GAAGD,WAAaS,YAAc,IAC5EkB,WAAa,CACXR,WAAY,EACZnB,UAAW,EACXE,YAAa,GAEf0B,UAAYZ,KAAK7C,OAAO8B,QAOxB4B,YAAcZ,QAAQK,OAA+B,IAAtBM,UAAU5B,cACd,IAA3BgB,KAAK3C,mBAA+BsD,WAAWR,aAAeH,KAAK3C,kBAAkB8C,YAAcU,YAAa,KAC9GC,iBAAmBhE,EAAE,IAAMkD,KAAKzC,GAAGO,gBAAgBiD,UACvDf,KAAKgB,mBAAqBhB,KAAK3C,kBAC/B2C,KAAK3C,kBAAoBsD,WACzBX,KAAK9C,SAASsB,SAAS+B,YAAYP,KAAKzC,GAAGO,gBAC3CkC,KAAK9C,SAAS4C,UAAUS,YAAYP,KAAKzC,GAAGO,iBACzB,IAAf6C,aAAsC,IAAdC,cACrB,IAAIK,cAAgBN,WAAWR,WAAa,EAAGc,eAAiBL,UAAUT,WAAYc,gBACzFnE,EAAE,IAAMkD,KAAKzC,GAAGI,WAAa,IAAMsD,eAAeC,SAAUlB,KAAKzC,GAAGO,gBACpEhB,EAAE,IAAMkD,KAAKzC,GAAGG,UAAY,IAAMuD,eAAeC,SAAUlB,KAAKzC,GAAGO,gBAGvEkC,KAAKmB,qBAAqBL,iBAAkBd,KAAKgB,mBAAoBhB,KAAK3C,kBAAmB2C,KAAK7C,WAkBxGgE,qBAAsB,SAASC,SAAUC,SAAUC,SAAUnE,QAC3DJ,IAAIE,MAAMmE,UACVrE,IAAIE,MAAMoE,UACVtE,IAAIE,MAAMqE"}