{"version":3,"file":"gradenowhelper.min.js","sources":["../src/gradenowhelper.js"],"sourcesContent":["define(['jquery', 'core/log', 'mod_readaloud/definitions', 'mod_readaloud/popoverhelper'], function ($, log, def, popoverhelper) {\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Gradenow helper: initialising');\n\n    return {\n        //controls\n\n        controls: {},\n        currentmode: 'grading',\n\n        constants: {\n            REVIEWMODE_NONE: 0,\n            REVIEWMODE_MACHINE: 1,\n            REVIEWMODE_HUMAN: 2,\n            REVIEWMODE_SCORESONLY: 3,\n            SESSIONSCORE_STRICT: 1\n        },\n\n        //class definitions\n        cd: {\n            audioplayerclass: def.audioplayerclass,\n            wordplayerclass: def.wordplayerclass,\n            wordclass: def.wordclass,\n            spaceclass: def.spaceclass,\n            badwordclass: def.badwordclass,\n            endspaceclass: def.endspaceclass,\n            unreadwordclass: def.unreadwordclass,\n            unreadspaceclass: def.unreadspaceclass,\n            wpmscoreid: def.wpmscoreid,\n            accuracyscoreid: def.accuracyscoreid,\n            sessionscoreid: def.sessionscoreid,\n            errorscoreid: def.errorscoreid,\n            formelementwpmscore: def.formelementwpmscore,\n            formelementaccuracy: def.formelementaccuracy,\n            formelementsessionscore: def.formelementsessionscore,\n            formelementendword: def.formelementendword,\n            formelementtime: def.formelementtime,\n            formelementerrors: def.formelementerrors,\n            modebutton: def.modebutton,\n\n            spotcheckbutton: def.spotcheckbutton,\n            transcriptcheckbutton: def.transcriptcheckbutton,\n            gradingbutton: def.gradingbutton,\n            clearbutton: def.clearbutton,\n            spotcheckmode: def.spotcheckmode,\n            aiunmatched: def.aiunmatched,\n            passagecontainer: def.passagecontainer,\n\n            maybeselfcorrectclass: def.maybeselfcorrectclass,\n            selfcorrectclass: def.selfcorrectclass,\n            notesclass: def.notesclass,\n            structuralclass: def.structuralclass,\n            meaningclass: def.meaningclass,\n            visualclass: def.visualclass,\n\n        },\n\n        options: {\n            enabletts: false,\n            targetwpm: 100,\n            ttslanguage: 'en',\n            totalseconds: 60,\n            allowearlyexit: false,\n            timelimit: 60,\n            enforcemarker: true,\n            totalwordcount: 0,\n            wpm: 0,\n            accuracy: 0,\n            sessionscore: 0,\n            sessionscoremethod: 0,\n            endwordnumber: 0,\n            errorwords: {},\n            activityid: null,\n            attemptid: null,\n            sesskey: null\n        },\n\n\n        init: function (config) {\n\n            //pick up opts from html\n            var theid = '#' + config['id'];\n            var configcontrol = $(theid).get(0);\n            if (configcontrol) {\n                var opts = JSON.parse(configcontrol.value);\n                $(theid).remove();\n            } else {\n                //if there is no config we might as well give up\n                log.debug('Gradenow helper js: No config found on page. Giving up.');\n                return;\n            }\n\n            //register the controls\n            this.register_controls();\n\n            //stash important info\n            this.options.activityid = opts['activityid'];\n            this.options.attemptid = opts['attemptid'];\n            this.options.sesskey = opts['sesskey'];\n            this.options.enabletts = opts['enabletts'];\n            this.options.ttslanguage = opts['ttslanguage'];\n            this.options.targetwpm = opts['targetwpm'];\n            this.options.sessionscoremethod = opts['sessionscoremethod'];\n            this.options.allowearlyexit = opts['allowearlyexit'];\n            this.options.timelimit = opts['timelimit'];\n            this.options.reviewmode = opts['reviewmode'];\n            this.options.readonly = opts['readonly'];\n            this.options.totalwordcount = $('.' + this.cd.wordclass).length;\n\n            if (opts['sessiontime'] > 0) {\n                if (opts['sessionerrors'] !== '') {\n                    this.options.errorwords = JSON.parse(opts['sessionerrors']);\n                } else {\n                    this.options.errorwords = {};\n                }\n                this.options.totalseconds = opts['sessiontime'];\n                this.options.endwordnumber = opts['sessionendword'];\n                this.options.sessionscore = opts['sessionscore'];\n                this.options.accuracy = opts['accuracy'];\n                this.options.wpm = opts['wpm'];\n\n                //We may have session matches and AI data, if AI is turned on\n                this.options.sessionmatches = JSON.parse(opts['sessionmatches']);\n                this.options.aidata = opts['aidata'];\n                if (this.options.aidata) {\n                    this.options.transcriptwords = opts['aidata'].transcript.split(\" \");\n\n                    //remove empty elements ... these can get in there\n                    this.options.transcriptwords = this.options.transcriptwords.filter(function (el) {\n                        return el !== '';\n                    });\n\n                } else {\n                    this.options.transcriptwords = [];\n                }\n\n                //if this has been graded, draw the gradestate\n                this.redrawgradestate();\n            } else {\n                //set up our end passage marker\n                this.options.endwordnumber = this.options.totalwordcount;\n            }\n\n            //add the endword marker\n            var thespace = $('#' + this.cd.spaceclass + '_' + this.options.endwordnumber);\n            thespace.addClass(this.cd.endspaceclass);\n\n            //register events\n            this.register_events();\n\n            //initialise our audio duration. We need this to calc. wpm\n            //but if allowearlyexit is false, actually we can skip waiting for audio.\n            //After audio loaded(if nec.) we call processscores to init score boxe\n            //TODO: really should get audio duration at recording time.\n            var m = this;\n            var processloadedaudio = function () {\n                if (m.options.allowearlyexit ||m.options.timelimit==0 ) {\n                    //using the audio player duration is actually more accurate than aidata.sessiontime\n                    //but it will give diff results to score used in autograding which when allowing earlyexit uses aiddata.sessiontime\n                    // (aidata.sessiontime is the end time of last recognised word.)\n                    //So to ensure consistency we also use the aidata.sessiontime here\n                    if (m.options.aidata && m.options.aidata.sessiontime) {\n                        m.options.totalseconds = m.options.aidata.sessiontime;\n                    } else {\n                        m.options.totalseconds = Math.round($('#' + m.cd.audioplayerclass).prop('duration'));\n                    }\n                } else {\n                    m.options.totalseconds = m.options.timelimit;\n                }\n                //update form field\n                m.controls.formelementtime.val(m.options.totalseconds);\n                m.processscores();\n            };\n\n\n            //we used to use the audio player time, but we try not to, and anyway its best not to\n            //depend on a duration being available. Audio might expire\n            /*\n            var audioplayer = $('#' + this.cd.audioplayerclass);\n            if (audioplayer.prop('readyState') < 1 && this.options.allowearlyexit) {\n                audioplayer.on('loadedmetadata', processloadedaudio);\n            } else {\n                processloadedaudio();\n            }\n            */\n            processloadedaudio();\n\n            //init our popover helper which sets up the button events\n            this.init_popoverhelper();\n\n\n        },\n\n        //set up events related to popover helper\n        init_popoverhelper: function () {\n            var that = this;\n\n            //when the user clicks the reject popover accept button, we arrive here\n            popoverhelper.onReject = function () {\n                var clickwordnumber = $(this).attr('data-wordnumber');\n\n                //if nothing changed, just close the popover\n                var nochange = (clickwordnumber in that.options.errorwords);\n                if (nochange) {\n                    popoverhelper.remove();\n                    return;\n                }\n\n                //if a new choice was made update things\n                var playchain = that.fetchPlayChain(clickwordnumber);\n                for (var wordindex = playchain.startword; wordindex <= playchain.endword; wordindex++) {\n                    if (!(wordindex in that.options.errorwords)) {\n                        var theword = $('#' + that.cd.wordclass + '_' + wordindex);\n                        var thespace = $('#' + that.cd.spaceclass + '_' + wordindex);\n                        if(wordindex==clickwordnumber) {\n                            that.adderrorword(wordindex, theword.text());\n                            theword.addClass(that.cd.badwordclass);\n                            theword.addClass(that.cd.spotcheckmode);\n                            if (wordindex !== playchain.endword) {\n                                thespace.addClass(that.cd.spotcheckmode);\n                            }\n                        }\n                    }\n                }\n                //that.markup_badspaces();\n                that.markup_aiunmatchedspaces();\n                that.processscores();\n                popoverhelper.remove();\n            };\n\n            //when the user clicks the popover accept button, we arrive here\n            popoverhelper.onAccept = function () {\n                var clickwordnumber = $(this).attr('data-wordnumber');\n\n                //if nothing changed, just close the popover\n                var nochange = !(clickwordnumber in that.options.errorwords);\n                if (nochange) {\n                    popoverhelper.remove();\n                    return;\n                }\n                //if a new choice was made update things\n                var playchain = that.fetchPlayChain(clickwordnumber);\n                for (var wordindex = playchain.startword; wordindex <= playchain.endword; wordindex++) {\n                    if (wordindex in that.options.errorwords) {\n                        if(wordindex==clickwordnumber) {\n                            delete that.options.errorwords[wordindex];\n                            var theword = $('#' + that.cd.wordclass + '_' + wordindex);\n                            var thespace = $('#' + that.cd.spaceclass + '_' + wordindex);\n                            theword.removeClass(that.cd.badwordclass);\n                            theword.removeClass(that.cd.spotcheckmode);\n                            thespace.removeClass(that.cd.spotcheckmode);\n                        }\n                    }\n                }\n                //that.markup_badspaces();\n                that.markup_aiunmatchedspaces();\n                that.processscores();\n                popoverhelper.remove();\n            };\n\n            //init the popover now that we have set the correct callback event handling thingies\n            popoverhelper.init();\n        },\n\n        register_controls: function () {\n\n            this.controls.wordplayer = $('#' + this.cd.wordplayerclass);\n            this.controls.audioplayer = $('#' + this.cd.audioplayerclass);\n            this.controls.eachword = $('.' + this.cd.wordclass);\n            this.controls.eachspace = $('.' + this.cd.spaceclass);\n            this.controls.endwordmarker = $('#' + this.cd.spaceclass + '_' + this.options.endwordnumber);\n            this.controls.spotcheckword = $('.' + this.cd.spotcheckmode);\n\n            this.controls.wpmscorebox = $('#' + this.cd.wpmscoreid);\n            this.controls.accuracyscorebox = $('#' + this.cd.accuracyscoreid);\n            this.controls.sessionscorebox = $('#' + this.cd.sessionscoreid);\n            this.controls.errorscorebox = $('#' + this.cd.errorscoreid);\n\n            this.controls.formelementwpmscore = $(\"#\" + this.cd.formelementwpmscore);\n            this.controls.formelementsessionscore = $(\"#\" + this.cd.formelementsessionscore);\n            this.controls.formelementaccuracy = $(\"#\" + this.cd.formelementaccuracy);\n            this.controls.formelementendword = $(\"#\" + this.cd.formelementendword);\n            this.controls.formelementerrors = $(\"#\" + this.cd.formelementerrors);\n            this.controls.formelementtime = $(\"#\" + this.cd.formelementtime);\n\n            this.controls.passagecontainer = $(\".\" + this.cd.passagecontainer);\n\n            //passage action buttons\n            this.controls.modebutton = $(\"#\" + this.cd.modebutton);\n\n            this.controls.gradingbutton = $(\"#\" + this.cd.gradingbutton);\n            this.controls.spotcheckbutton = $(\"#\" + this.cd.spotcheckbutton);\n            this.controls.transcriptcheckbutton = $(\"#\" + this.cd.transcriptcheckbutton);\n            this.controls.clearbutton = $(\"#\" + this.cd.clearbutton);\n\n        },\n\n        register_events: function () {\n            var that = this;\n            //set up event handlers\n\n\n            //Play audio from and to spot check part\n            this.controls.passagecontainer.on('click', '.' + this.cd.spotcheckmode + ', .' + this.cd.aiunmatched, function () {\n                if (that.currentmode === 'spotcheck') {\n                    var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                    that.doPlaySpotCheck(wordnumber);\n                }\n            });\n\n\n            //in review mode, do nuffink though ... thats for the student\n            if (this.options.readonly) {\n                //do nothing\n\n                //here we will put real options for playing the model reading and user reading etc\n            } else if (false) {\n                /*\n                if(this.enabletts && this.options.ttslanguage != 'none'){\n                    this.controls.eachword.click(this.playword);\n                }\n                */\n\n                //if we have AI data then turn on spotcheckmode\n                if (this.options.sessionmatches) {\n                    this.doSpotCheckMode();\n                }\n\n                //add listeners for click events\n                this.controls.eachword.click(\n                    function () {\n                        //if we are in spotcheck mode just return, we do not grade\n                        if (that.currentmode === 'spotcheck') {\n                            return;\n                        }\n\n                        //get the word that was clicked\n                        var wordnumber = $(this).attr('data-wordnumber');\n                        var theword = $(this).text();\n\n                        if (that.currentmode === 'transcriptcheck') {\n                            var chunk = that.fetchTranscriptChunk(wordnumber);\n                            if (chunk) {\n                                popoverhelper.addTranscript(this, chunk);\n                            }\n\n\n                        }\n                    });\n\n                //if not in review mode\n            } else {\n\n                //process word clicks\n                this.controls.eachword.click(\n                    function () {\n\n\n                        //get the word that was clicked\n                        var wordnumber = $(this).attr('data-wordnumber');\n                        var theword = $(this).text();\n\n                        //if we are in spotcheck mode lets enable quick grade popovers\n                        if (that.currentmode === 'spotcheck') {\n                            if ($(this).hasClass(that.cd.badwordclass) || $(this).hasClass(that.cd.aiunmatched)) {\n                                popoverhelper.addQuickGrader(this);\n                            }\n                            return;\n                        }\n\n                        if (that.currentmode === 'transcriptcheck') {\n                            var chunk = that.fetchTranscriptChunk(wordnumber);\n                            if (chunk) {\n                                popoverhelper.addTranscript(this, chunk);\n                            }\n                            return;\n                        }\n\n                        //this will disallow badwords after the endmarker\n                        if (that.options.enforcemarker && Number(wordnumber) > Number(that.options.endwordnumber)) {\n                            return;\n                        }\n\n                        if (wordnumber in that.options.errorwords) {\n                            delete that.options.errorwords[wordnumber];\n                            $(this).removeClass(that.cd.badwordclass);\n                        } else {\n                            that.adderrorword(wordnumber, theword);\n                            $(this).addClass(that.cd.badwordclass);\n                        }\n                        that.processscores();\n                    }\n                ); //end of each word click\n\n                //process space clicks\n                this.controls.eachspace.click(\n                    function () {\n\n                        //if we are in spotcheck or transcript check mode just return, we do not grade\n                        if (that.currentmode === 'spotcheck' || that.currentmode === 'transcriptcheck') {\n                            return;\n                        }\n\n                        //this event is entered by  click on space\n                        //it relies on attr data-wordnumber being set correctly\n                        var wordnumber = $(this).attr('data-wordnumber');\n                        var thespace = $('#' + that.cd.spaceclass + '_' + wordnumber);\n\n                        if (wordnumber === that.options.endwordnumber) {\n                            that.options.endwordnumber = that.options.totalwordcount;\n                            thespace.removeClass(that.cd.endspaceclass);\n                            $('#' + that.cd.spaceclass + '_' + that.options.totalwordcount).addClass(that.cd.endspaceclass);\n                        } else {\n                            $('#' + that.cd.spaceclass + '_' + that.options.endwordnumber).removeClass(that.cd.endspaceclass);\n                            that.options.endwordnumber = wordnumber;\n                            thespace.addClass(that.cd.endspaceclass);\n                        }\n                        that.processunread();\n                        that.processscores();\n                    }\n                );//end of each space click\n\n                //process clearbutton's click event\n                this.controls.clearbutton.click(function () {\n\n                    //if we are in spotcheck or transcript check mode just return, we do not grade\n                    if (that.currentmode === 'spotcheck' || that.currentmode === 'transcriptcheck') {\n                        return;\n                    }\n\n                    //clear all the error words\n                    $('.' + that.cd.badwordclass).each(function (index) {\n                        var wordnumber = $(this).attr('data-wordnumber');\n                        delete that.options.errorwords[wordnumber];\n                        $(this).removeClass(that.cd.badwordclass);\n                    });\n\n                    //remove unread words\n                    $('.' + that.cd.wordclass).removeClass(that.cd.unreadwordclass);\n\n                    //set endspace to last space\n                    that.options.endwordnumber = that.options.totalwordcount;\n                    $('.' + that.cd.spaceclass).removeClass(that.cd.endspaceclass);\n                    $('#' + that.cd.spaceclass + '_' + that.options.totalwordcount).addClass(that.cd.endspaceclass);\n\n                    //reprocess scores\n                    that.processscores();\n                });\n\n\n                //modebutton: turn on grading\n                this.controls.gradingbutton.click(function () {\n                    that.undoCurrentMode();\n                    that.doGradingMode();\n                    that.updateButtonStates();\n                });\n\n            }//end of if/else reviewmode\n\n            //either in or out of review mode we want these\n            //modebutton: turn on spotchecking\n            this.controls.spotcheckbutton.click(function () {\n                that.undoCurrentMode();\n                that.doSpotCheckMode();\n                that.updateButtonStates();\n            });\n\n            //modebutton: turn on transcript checking\n            this.controls.transcriptcheckbutton.click(function () {\n                that.undoCurrentMode();\n                that.doTranscriptCheckMode();\n                that.updateButtonStates();\n            });\n\n\n        },\n\n        undoCurrentMode: function () {\n            switch (this.currentmode) {\n                case 'grading':\n                    //we do not undo this, its the default\n                    break;\n                case 'spotcheck':\n                    this.undoSpotCheckMode();\n                    break;\n                case 'transcriptcheck':\n                    this.undoTranscriptCheckMode();\n                    break;\n            }\n\n        },\n\n        updateButtonStates: function () {\n            switch (this.currentmode) {\n                case 'grading':\n                    this.controls.gradingbutton.prop('disabled', true);\n                    this.controls.spotcheckbutton.prop('disabled', false);\n                    this.controls.transcriptcheckbutton.prop('disabled', false);\n                    break;\n                case 'spotcheck':\n                    this.controls.gradingbutton.prop('disabled', false);\n                    this.controls.spotcheckbutton.prop('disabled', true);\n                    this.controls.transcriptcheckbutton.prop('disabled', false);\n                    break;\n                case 'transcriptcheck':\n                    this.controls.gradingbutton.prop('disabled', false);\n                    this.controls.spotcheckbutton.prop('disabled', false);\n                    this.controls.transcriptcheckbutton.prop('disabled', true);\n                    break;\n            }\n\n        },\n\n        /*\n        * Here we fetch the playchain, start playing frm audiostart and add an event handler to stop at audioend\n         */\n        doPlaySpotCheck: function (spotcheckindex) {\n            var playchain = this.fetchPlayChain(spotcheckindex);\n            var theplayer = this.controls.audioplayer[0];\n            //we pad the play audio by 0.5 seconds beginning and end\n            var pad = 0.5;\n            var duration = theplayer.duration;\n            //determine starttime\n            var endtime = parseFloat(playchain.audioend);\n            if (!isNaN(duration) && duration > (endtime + pad)) {\n                endtime = endtime + pad;\n            }\n            //determine endtime\n            var starttime = parseFloat(playchain.audiostart);\n            if ((starttime - pad) > 0) {\n                starttime = starttime - pad;\n            }\n\n            theplayer.currentTime = starttime;\n            $(this.controls.audioplayer).off(\"timeupdate\");\n            $(this.controls.audioplayer).on(\"timeupdate\", function (e) {\n                var currenttime = theplayer.currentTime;\n                if (currenttime >= endtime) {\n                    $(this).off(\"timeupdate\");\n                    theplayer.pause();\n                }\n            });\n            theplayer.play();\n        },\n\n        /*\n        * The playchain is all the words in a string of badwords.\n        * The complexity comes because a bad word  is usually one that isunmatched by AI.\n        * So if the teacher clicks on a passage word that did not appear in the transcript, what should we play?\n        * Answer: All the words from the last known to the next known word. Hence we create a play chain\n        * For consistency, if the teacher flags matched words as bad, while we do know their precise location we still\n        * make a play chain. Its not a common situation probably.\n         */\n        fetchPlayChain: function (spotcheckindex) {\n\n            //find startword\n            var startindex = spotcheckindex;\n            var starttime = -1;\n            for (var wordnumber = spotcheckindex; wordnumber > 0; wordnumber--) {\n                var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if current wordnumber part of the playchain, set it as the startindex.\n                // And get the audiotime if its a matched word. (we only know audiotime of matched words)\n                if (isbad || isunmatched) {\n                    startindex = wordnumber;\n                    if (!isunmatched) {\n                        starttime = this.options.sessionmatches['' + wordnumber].audiostart;\n                    } else {\n                        starttime = -1;\n                    }\n                } else {\n                    break;\n                }\n            }//end of for loop --\n            //if we have no starttime then we need to get the next matched word's audioend and use that\n            if (starttime === -1) {\n                starttime = 0;\n                for (var wordnumber = startindex - 1; wordnumber > 0; wordnumber--) {\n                    if (this.options.sessionmatches['' + wordnumber]) {\n                        starttime = this.options.sessionmatches['' + wordnumber].audioend;\n                        break;\n                    }\n                }\n            }\n\n            //find endword\n            var endindex = spotcheckindex;\n            var endtime = -1;\n            var passageendword = this.options.totalwordcount;\n            for (var wordnumber = spotcheckindex; wordnumber <= passageendword; wordnumber++) {\n                var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if its part of the playchain, set it to startindex. And get time if its a matched word.\n                if (isbad || isunmatched) {\n                    endindex = wordnumber;\n                    if (!isunmatched) {\n                        endtime = this.options.sessionmatches['' + wordnumber].audioend;\n                    } else {\n                        endtime = -1;\n                    }\n                } else {\n                    break;\n                }\n            }//end of for loop --\n            //if we have no endtime then we need to get the next matched word's audiostart and use that\n            if (endtime === -1) {\n                endtime = this.options.totalseconds;\n                for (var wordnumber = endindex + 1; wordnumber <= passageendword; wordnumber++) {\n                    if (this.options.sessionmatches['' + wordnumber]) {\n                        endtime = this.options.sessionmatches['' + wordnumber].audiostart;\n                        break;\n                    }\n                }\n            }\n            var playchain = {};\n            playchain.startword = startindex;\n            playchain.endword = parseInt(endindex);\n            playchain.audiostart = starttime;\n            playchain.audioend = parseInt(endtime);\n            //console.log('audiostart:' + starttime);\n            //console.log('audioend:' + endtime);\n\n            return playchain;\n\n        },\n\n        /*\n        * Here we mark up the passage for spotcheck mode. This will make up the spaces and the words as either badwords\n        * or aiunmatched words. We need to create playchains so aiunmatched still is indeicated visibly even where its\n        * not a badword (ie has been corrected)\n         */\n        doSpotCheckMode: function () {\n            var that = this;\n\n            //mark up all ai unmatched words as aiunmatched\n            this.markup_aiunmatchedwords();\n\n            //mark up all badwords as spotcheck words\n            $('.' + this.cd.badwordclass).addClass(this.cd.spotcheckmode);\n\n            //mark up spaces between spotcheck word and spotcheck/aiunmatched word (bad spaces)\n            //this.markup_badspaces();\n\n            //mark up spaces between aiunmatched word and spotcheck/aiunmatched word (aiunmatched spaces)\n            this.markup_aiunmatchedspaces();\n\n            this.currentmode = \"spotcheck\";\n        },\n\n        //mark up all ai unmatched words as aiunmatched\n        markup_aiunmatchedwords: function () {\n            var that = this;\n            if (this.options.sessionmatches) {\n                var prevmatch = 0;\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var unmatchedcount = index - prevmatch - 1;\n                    if (unmatchedcount > 0) {\n                        for (var errorword = 1; errorword < unmatchedcount + 1; errorword++) {\n                            var wordnumber = prevmatch + errorword;\n                            $('#' + that.cd.wordclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                        }\n                    }\n                    prevmatch = parseInt(index);\n                });\n\n                //mark all words from last matched word to the end as aiunmatched\n                for (var errorword = prevmatch + 1; errorword <= this.options.endwordnumber; errorword++) {\n                    $('#' + that.cd.wordclass + '_' + errorword).addClass(that.cd.aiunmatched);\n                }\n            }\n\n        },\n\n        //mark up spaces between spotcheck word and spotcheck/aiunmatched word (bad spaces)\n        /* NO LONGER USED  */\n        markup_badspaces: function () {\n            var that = this;\n            //mark up spaces between spotcheck word and spotcheck/aiunmatched word (bad spaces)\n            $('.' + this.cd.badwordclass + '.' + this.cd.spotcheckmode).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.spotcheckmode) ||\n                    $('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.spotcheckmode);\n                }\n            });\n        },\n\n        markup_aiunmatchedspaces: function () {\n            var that = this;\n            $('.' + this.cd.wordclass + '.' + this.cd.aiunmatched).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.spotcheckmode) ||\n                    $('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                }\n            });\n        },\n\n\n        undoSpotCheckMode: function () {\n            $('.' + this.cd.badwordclass).removeClass(this.cd.spotcheckmode);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.spotcheckmode);\n            $('.' + this.cd.wordclass).removeClass(this.cd.aiunmatched);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.aiunmatched);\n            $(this.controls.audioplayer).off(\"timeupdate\");\n            popoverhelper.remove();\n        },\n\n        /*\n       * Here we mark up the passage for transcriptcheck mode.\n        */\n        doTranscriptCheckMode: function () {\n            var that = this;\n            //mark up all ai unmatched words as transcriptcheck\n            if (this.options.sessionmatches) {\n                var prevmatch = 0;\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var unmatchedcount = index - prevmatch - 1;\n                    if (unmatchedcount > 0) {\n                        for (var errorword = 1; errorword < unmatchedcount + 1; errorword++) {\n                            var wordnumber = prevmatch + errorword;\n                            $('#' + that.cd.wordclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                        }\n                    }\n                    prevmatch = parseInt(index);\n                });\n\n                //mark all words from last matched word to the end as aiunmatched\n                for (var errorword = prevmatch + 1; errorword <= this.options.endwordnumber; errorword++) {\n                    $('#' + that.cd.wordclass + '_' + errorword).addClass(that.cd.aiunmatched);\n                }\n            }\n\n            //mark up spaces between aiunmatched word and aiunmatched (bad spaces)\n            $('.' + this.cd.aiunmatched).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                }\n            });\n\n            this.currentmode = \"transcriptcheck\";\n        },\n\n        undoTranscriptCheckMode: function () {\n            $('.' + this.cd.wordclass).removeClass(this.cd.aiunmatched);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.aiunmatched);\n            popoverhelper.remove();\n        },\n\n        doGradingMode: function () {\n            this.currentmode = \"grading\";\n        },\n\n        /*\n       * This will take a wordindex and find the previous and next transcript indexes that were matched and\n       * return all the transcript words in between those.\n        */\n        fetchTranscriptChunk: function (checkindex) {\n\n            var transcriptlength = this.options.transcriptwords.length;\n            if (transcriptlength === 0) {\n                return \"\";\n            }\n\n            //find startindex\n            var startindex = -1;\n            for (var wordnumber = checkindex; wordnumber > 0; wordnumber--) {\n\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if we matched then the subsequent transcript word is the last unmatched one in the checkindex sequence\n                if (!isunmatched) {\n                    startindex = this.options.sessionmatches['' + wordnumber].tposition + 1;\n                    break;\n                }\n            }//end of for loop\n\n            //find endindex\n            var endindex = -1;\n            for (var wordnumber = checkindex; wordnumber <= transcriptlength; wordnumber++) {\n\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if we matched then the previous transcript word is the last unmatched one in the checkindex sequence\n                if (!isunmatched) {\n                    endindex = this.options.sessionmatches['' + wordnumber].tposition - 1;\n                    break;\n                }\n            }//end of for loop --\n\n            //if there was no previous matched word, we set start to 1\n            if (startindex === -1) {\n                startindex = 1;\n            }\n            //if there was no subsequent matched word we flag the end as the -1\n            if (endindex === transcriptlength) {\n                endindex = -1;\n                //an edge case is where the first word is not in transcript and first match is the second or later passage\n                //word. It might not be possible for endindex to be lower than start index, but we don't want it anyway\n            } else if (endindex === 0 || endindex < startindex) {\n                return false;\n            }\n\n            //up until this point the indexes have started from 1, since the passage word numbers start from 1\n            //but the transcript array is 0 based so we adjust. array splice function does not include item and endindex\n            ///so it needs to be one more then start index. hence we do not adjust that\n            startindex--;\n\n            //finally we return the section\n            var ret = false;\n            if (endindex > 0) {\n                ret = this.options.transcriptwords.slice(startindex, endindex).join(\" \");\n            } else {\n                ret = this.options.transcriptwords.slice(startindex).join(\" \");\n            }\n            if (ret.trim() === '') {\n                return false;\n            } else {\n                return ret;\n            }\n        },\n\n\n        playword: function () {\n            var m = this;//M.mod_readaloud.gradenowhelper;\n            m.controls.wordplayer.attr('src', M.cfg.wwwroot + '/mod/readaloud/tts.php?txt=' + encodeURIComponent($(this).text())\n                + '&lang=' + m.options.ttslanguage + '&n=' + m.options.activityid);\n            m.controls.wordplayer[0].pause();\n            m.controls.wordplayer[0].load();\n            m.controls.wordplayer[0].play();\n        },\n        redrawgradestate: function () {\n            var m = this;\n            this.processunread();\n            if (this.options.reviewmode !== this.constants.REVIEWMODE_SCORESONLY) {\n                $.each(m.options.errorwords, function (index) {\n                        $('#' + m.cd.wordclass + '_' + m.options.errorwords[index].wordnumber).addClass(m.cd.badwordclass);\n                    }\n                );\n            }\n\n            this.markup_maybeselfcorrects();\n\n        },\n        adderrorword: function (wordnumber, word) {\n            this.options.errorwords[wordnumber] = {word: word, wordnumber: wordnumber};\n            //console.log(this.errorwords);\n\n        },\n        processword: function () {\n            var m = this;\n            var wordnumber = $(this).attr('data-wordnumber');\n            var theword = $(this).text();\n            //this will disallow badwords after the endmarker\n            if (m.options.enforcemarker && Number(wordnumber) > Number(m.options.endwordnumber)) {\n                return;\n            }\n\n            if (wordnumber in m.options.errorwords) {\n                delete m.options.errorwords[wordnumber];\n                $(this).removeClass(m.cd.badwordclass);\n            } else {\n                m.adderrorword(wordnumber, theword);\n                $(this).addClass(m.cd.badwordclass);\n            }\n            m.processscores();\n        },\n        //this function is never called it seems ....\n        processspace: function () {\n            //this event is entered by  click on space\n            //it relies on attr data-wordnumber being set correctly\n            var m = this;\n            var wordnumber = $(this).attr('data-wordnumber');\n            var thespace = $('#' + m.cd.spaceclass + '_' + wordnumber);\n\n            if (wordnumber === m.options.endwordnumber) {\n                m.options.endwordnumber = m.options.totalwordcount;\n                thespace.removeClass(m.cd.endspaceclass);\n                $('#' + m.cd.spaceclass + '_' + m.options.totalwordcount).addClass(m.cd.endspaceclass);\n            } else {\n                $('#' + m.cd.spaceclass + '_' + m.options.endwordnumber).removeClass(m.cd.endspaceclass);\n                m.options.endwordnumber = wordnumber;\n                thespace.addClass(m.cd.endspaceclass);\n            }\n            m.processunread();\n            m.processscores();\n        },\n\n        markup_maybeselfcorrects: function () {\n            var that = this;\n            if (this.options.sessionmatches) {\n                var prevmatch = false;\n                //loop through matches checking for insertions prior to matches\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var maybe = false; // insertions exist between this match and prev match\n                    var verymaybe = false; //this word is matched and prev word is matched, but insertions exist\n\n                    if (prevmatch) {\n                        if (match.tposition - prevmatch.tposition > 1 && match.pposition - prevmatch.pposition === 1) {\n                            maybe = true;\n                            verymaybe = true;\n                        } else {\n                            if (match.tposition - prevmatch.tposition > 1) {\n                                maybe = true;\n                            }\n                        }\n                    } else if (prevmatch === false) {\n                        if (match.pposition < match.tposition) {\n                            maybe = true;\n                        }\n                    }\n                    //for now we will just work with very maybes, but we could do maybes\n                    if (verymaybe) {\n                        $('#' + that.cd.wordclass + '_' + match.pposition).addClass(that.cd.maybeselfcorrectclass);\n                    }\n                    prevmatch = match;\n                });\n            }\n        },\n\n        processunread: function () {\n            var m = this;\n            m.controls.eachword.each(function (index) {\n                var wordnumber = $(this).attr('data-wordnumber');\n                var thespace = $('#' + m.cd.spaceclass + '_' + wordnumber);\n\n                if (Number(wordnumber) > Number(m.options.endwordnumber)) {\n                    $(this).addClass(m.cd.unreadwordclass);\n                    thespace.addClass(m.cd.unreadspaceclass);\n\n                    //this will clear badwords after the endmarker\n                    if (m.options.enforcemarker && wordnumber in m.options.errorwords) {\n                        delete m.options.errorwords[wordnumber];\n                        $(this).removeClass(m.cd.badwordclass);\n                    }\n                } else {\n                    $(this).removeClass(m.cd.unreadwordclass);\n                    thespace.removeClass(m.cd.unreadspaceclass);\n                }\n            });\n        },\n        processscores: function () {\n            var m = this;\n            var errorscore = Object.keys(m.options.errorwords).length;\n            m.controls.errorscorebox.text(errorscore);\n\n            //wpm score\n            //we do not apply accuracy adjustment here, that is only for machine grades.\n            var wpmscore = 0;\n            var strictwpmscore = 0;\n            var totalwords=m.options.endwordnumber - errorscore;\n            if (m.options.totalseconds > 0) {\n\n                //regular WPM\n                wpmscore = Math.round((totalwords * 60) / m.options.totalseconds);\n\n                //strict WPM for grading\n                totalwords = totalwords - errorscore;\n                if(totalwords < 0){totalwords =0;}\n                strictwpmscore = Math.round((totalwords * 60) / m.options.totalseconds);\n            }\n            m.options.wpm = wpmscore;\n            m.controls.wpmscorebox.text(wpmscore);\n\n            //accuracy score\n            var accuracyscore = 0;\n            if (m.options.endwordnumber > 0) {\n                accuracyscore = Math.round((m.options.endwordnumber - errorscore) / m.options.endwordnumber * 100);\n            }\n            m.options.accuracy = accuracyscore;\n            m.controls.accuracyscorebox.text(accuracyscore);\n\n            //sessionscore\n            if(m.options.sessionscoremethod == m.constants.SESSIONSCORE_STRICT) {\n                var usewpmscore = strictwpmscore;\n            }else{\n                var usewpmscore = wpmscore;\n            }\n\n            if (usewpmscore > m.options.targetwpm) {\n                usewpmscore = m.options.targetwpm;\n            }\n            var sessionscore = Math.round(usewpmscore / m.options.targetwpm * 100);\n            m.controls.sessionscorebox.text(sessionscore);\n\n            //update form field\n            m.controls.formelementwpmscore.val(wpmscore);\n            m.controls.formelementsessionscore.val(sessionscore);\n            m.controls.formelementaccuracy.val(accuracyscore);\n            m.controls.formelementendword.val(m.options.endwordnumber);\n            m.controls.formelementerrors.val(JSON.stringify(m.options.errorwords));\n\n        }\n\n    };\n});"],"names":["define","$","log","def","popoverhelper","debug","controls","currentmode","constants","REVIEWMODE_NONE","REVIEWMODE_MACHINE","REVIEWMODE_HUMAN","REVIEWMODE_SCORESONLY","SESSIONSCORE_STRICT","cd","audioplayerclass","wordplayerclass","wordclass","spaceclass","badwordclass","endspaceclass","unreadwordclass","unreadspaceclass","wpmscoreid","accuracyscoreid","sessionscoreid","errorscoreid","formelementwpmscore","formelementaccuracy","formelementsessionscore","formelementendword","formelementtime","formelementerrors","modebutton","spotcheckbutton","transcriptcheckbutton","gradingbutton","clearbutton","spotcheckmode","aiunmatched","passagecontainer","maybeselfcorrectclass","selfcorrectclass","notesclass","structuralclass","meaningclass","visualclass","options","enabletts","targetwpm","ttslanguage","totalseconds","allowearlyexit","timelimit","enforcemarker","totalwordcount","wpm","accuracy","sessionscore","sessionscoremethod","endwordnumber","errorwords","activityid","attemptid","sesskey","init","config","theid","configcontrol","get","opts","JSON","parse","value","remove","register_controls","reviewmode","readonly","this","length","sessionmatches","aidata","transcriptwords","transcript","split","filter","el","redrawgradestate","addClass","register_events","m","sessiontime","Math","round","prop","val","processscores","init_popoverhelper","that","onReject","clickwordnumber","attr","playchain","fetchPlayChain","wordindex","startword","endword","theword","thespace","adderrorword","text","markup_aiunmatchedspaces","onAccept","removeClass","wordplayer","audioplayer","eachword","eachspace","endwordmarker","spotcheckword","wpmscorebox","accuracyscorebox","sessionscorebox","errorscorebox","on","wordnumber","parseInt","doPlaySpotCheck","click","Number","chunk","fetchTranscriptChunk","addTranscript","hasClass","addQuickGrader","processunread","each","index","undoCurrentMode","doGradingMode","updateButtonStates","doSpotCheckMode","doTranscriptCheckMode","undoSpotCheckMode","undoTranscriptCheckMode","spotcheckindex","theplayer","duration","endtime","parseFloat","audioend","isNaN","starttime","audiostart","currentTime","off","e","pause","play","startindex","isbad","isunmatched","endindex","passageendword","markup_aiunmatchedwords","prevmatch","match","unmatchedcount","errorword","markup_badspaces","checkindex","transcriptlength","tposition","ret","slice","join","trim","playword","M","cfg","wwwroot","encodeURIComponent","load","markup_maybeselfcorrects","word","processword","processspace","verymaybe","pposition","errorscore","Object","keys","wpmscore","strictwpmscore","totalwords","accuracyscore","usewpmscore","stringify"],"mappings":"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"}