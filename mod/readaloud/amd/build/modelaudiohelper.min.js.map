{"version":3,"file":"modelaudiohelper.min.js","sources":["../src/modelaudiohelper.js"],"sourcesContent":["define(['jquery', 'core/log','mod_readaloud/definitions','mod_readaloud/recorderhelper','mod_readaloud/modelaudiokaraoke'], function ($, log, def, recorderhelper, karaoke) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file helps you get Polly URLs at runtime\n     */\n\n    log.debug('Model Audio helper: initialising');\n\n    return {\n        controls: {},\n        currentmode: 'modeling', //previewing //stopped\n        breaks: [],\n        matches: false,\n        goturl: false,\n\n        //class definitions\n        cd: {\n            audioplayerclass: def.modelaudioplayerclass,\n            wordclass: def.wordclass,\n            spaceclass: def.spaceclass,\n            endspaceclass: def.endspaceclass,\n            passagecontainer: def.passagecontainer,\n            breaksfield: def.modelaudiobreaksfield,\n            urlfield: def.modelaudiourlfield,\n            modeltranscriptbutton: def.modeltranscriptbutton,\n            modeltranscript: def.modeltranscript\n        },\n\n        //init the module\n        init: function(props){\n\n            //pick up opts from html\n            var theid = '#amdopts_' + props.widgetid;\n            var configcontrol = $(theid).get(0);\n            if (configcontrol) {\n                var opts = JSON.parse(configcontrol.value);\n                $(theid).remove();\n            } else {\n                //if there is no config we might as well give up\n                log.debug('Read Aloud model audio Controller: No config found on page. Giving up.');\n                return;\n            }\n\n            if(opts.modelaudiobreaks) {\n                this.breaks=JSON.parse(opts.modelaudiobreaks);\n            }\n            if(opts.modelaudiomatches) {\n                this.matches=JSON.parse(opts.modelaudiomatches);\n            }\n\n            //register the controls\n            this.register_controls();\n            //register the events\n            this.register_events();\n            //markup passage\n            this.markup_passage();\n            //load recorder\n            this.init_recorder(opts);\n\n            //init karaoke\n            this.init_karaoke();\n\n            //if it looks like we have a human audio, do a transcript check\n            var audiourl = this.controls.audioplayer.attr('src');\n            if(audiourl != null && !audiourl.includes('poodllfile.poodll.net')) {\n                //this transcript check needs work. for now lets ignore it\n                //this.check_modelaudio_transcript_ready(audiourl, 5000)\n            }\n        },\n\n        init_karaoke: function(){\n          var karaoke_opts={audioplayerclass: this.cd.audioplayerclass, modeling: true};\n          karaoke.init(karaoke_opts);\n          karaoke.set_breaks(this.breaks);\n        },\n\n        init_recorder: function(opts){\n            var that =this;\n            var on_recording_start=function(eventdata){\n                that.goturl=false;\n            };\n            var on_recording_end=function(eventdata){};\n            var on_audio_processing=function(eventdata){\n                if(!that.goturl) {\n                    that.controls.urlfield.val(eventdata.mediaurl);\n                    that.goturl = true;\n                }\n            };\n\n            //init the recorder\n            recorderhelper.init(opts,\n                on_recording_start,\n                on_recording_end,\n                on_audio_processing);\n        },\n\n        //load all the controls so we do not have to do it later\n        register_controls: function(){\n            this.controls.audioplayer = $('#' + this.cd.audioplayerclass);\n            this.controls.eachword = $('.' + this.cd.wordclass);\n            this.controls.eachspace = $('.' + this.cd.spaceclass);\n            this.controls.passagecontainer = $(\".\" + this.cd.passagecontainer);\n            this.controls.breaksfield = $(\"#\" + this.cd.breaksfield);\n            this.controls.urlfield = $(\"#\" + this.cd.urlfield);\n            this.controls.modeltranscript = $(\"#\" + this.cd.modeltranscript);\n            this.controls.modeltranscriptbutton = $(\"#\" + this.cd.modeltranscriptbutton);\n        },\n\n        //attach the various event handlers we need\n        register_events: function(){\n            var that = this;\n\n            var clickhandler = function () {\n\n                if (that.currentmode === 'modeling') {\n                    var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                    var nextspace = $('#' + that.cd.spaceclass + '_' + wordnumber);\n                    if(nextspace.hasClass(that.cd.endspaceclass)){\n                        that.remove_break(wordnumber);\n                        nextspace.removeClass(that.cd.endspaceclass);\n                    }else {\n                        nextspace.addClass(that.cd.endspaceclass);\n                        var theplayer = that.controls.audioplayer[0];\n                        var audiotime = that.fetch_break_audiotime(wordnumber, theplayer, that.matches);\n                        that.register_break(wordnumber, audiotime);\n                    }\n                }\n            };\n\n            //set break points\n            this.controls.eachword.click(clickhandler);\n            this.controls.eachspace.click(clickhandler);\n\n            this.controls.modeltranscriptbutton.click(function(){\n                $(this).hide();\n                that.controls.modeltranscript.show();\n            });\n        },\n        remove_break: function(wordnumber)\n        {\n            for(var i=0; i<this.breaks.length; i++) {\n                if(this.breaks[i].wordnumber==wordnumber){\n                    this.breaks.splice(i,1);\n                    break;\n                }\n            }\n            this.controls.breaksfield.val(JSON.stringify(this.breaks));\n            karaoke.set_breaks(this.breaks);\n            log.debug(this.breaks);\n        },\n\n        register_break: function(wordnumber, audiotime){\n            this.breaks.push({'wordnumber': wordnumber, 'audiotime': audiotime});\n\n            var compare = function( a, b ) {\n                if ( a.wordnumber < b.wordnumber ){\n                    return -1;\n                }\n                if (  a.wordnumber >  b.wordnumber ){\n                    return 1;\n                }\n                return 0;\n            };\n            this.breaks.sort( compare );\n\n            this.controls.breaksfield.val(JSON.stringify(this.breaks));\n            karaoke.set_breaks(this.breaks);\n            log.debug(this.breaks);\n        },\n\n        markup_passage: function(){\n            for(var i=0; i<this.breaks.length; i++) {\n                var wordnumber =this.breaks[i].wordnumber;\n                var space =$('#' + this.cd.spaceclass + '_' + wordnumber);\n                space.addClass(this.cd.endspaceclass);\n            }\n\n        },\n\n        player_get_time: function(){\n            var theplayer = this.controls.audioplayer[0];\n            return theplayer.currentTime;\n        },\n\n        //the break occurs after the current word.  matches array  is 0 based and words array is 1 based\n        //So if break 1: word tapped is wordnumber 3, we want the start position of wordnumber 4 as audiotime. That is matches[3].audiostart\n        fetch_break_audiotime: function(wordnumber,theplayer, matches){\n            if(matches!==false && !$('.mod_readaloud_manualbreaktiming').is(\":checked\")){\n                if(matches[wordnumber]){\n                    return matches[wordnumber].audiostart;\n\n                }else{\n                    //try five more words, just in case\n                    for(var i =1;i<6;i++){\n                        if(matches[wordnumber+i]){\n                            return matches[wordnumber+i].audiostart;\n                        }\n                    }\n                }\n            }else {\n                return theplayer.currentTime;\n            }\n        },\n\n        check_modelaudio_transcript_ready: function(audiourl,waitms){\n            //we commence a series of ping and retries until the recorded file is available\n            var that = this;\n            $.ajax({\n                url: audiourl + '.txt',\n                method: 'HEAD',\n                cache: false,\n                error: function () {\n                    //We get here if its a 404 or 403. So settimout here and wait for file to arrive\n                    //we increment the timeout period each time to prevent bottlenecks\n                    log.debug('403 errors are normal here, till the file arrives back from transcriptoin');\n                    setTimeout(function () {\n                        that.check_modelaudio_transcript_ready(audiourl, waitms + 5000);\n                    }, waitms);\n                },\n                success: function (data, textStatus, xhr) {\n                    switch (xhr.status) {\n                        case 200:\n                            that.controls.modeltranscript.load(audiourl + '.txt');\n                            that.controls.modeltranscriptbutton.show();\n                            break;\n                        default:\n                            setTimeout(function () {\n                                that.check_modelaudio_transcript_ready(audiourl, waitms + 5000);\n                            }, waitms);\n                    }\n\n                }\n            });\n        },\n\n        do_transcription_complete: function(){\n\n        }\n\n    };//end of return value\n});"],"names":["define","$","log","def","recorderhelper","karaoke","debug","controls","currentmode","breaks","matches","goturl","cd","audioplayerclass","modelaudioplayerclass","wordclass","spaceclass","endspaceclass","passagecontainer","breaksfield","modelaudiobreaksfield","urlfield","modelaudiourlfield","modeltranscriptbutton","modeltranscript","init","props","theid","widgetid","configcontrol","get","opts","JSON","parse","value","remove","modelaudiobreaks","modelaudiomatches","register_controls","register_events","markup_passage","init_recorder","init_karaoke","audiourl","this","audioplayer","attr","includes","karaoke_opts","modeling","set_breaks","that","eventdata","val","mediaurl","eachword","eachspace","clickhandler","wordnumber","parseInt","nextspace","hasClass","remove_break","removeClass","addClass","theplayer","audiotime","fetch_break_audiotime","register_break","click","hide","show","i","length","splice","stringify","push","sort","a","b","player_get_time","currentTime","is","audiostart","check_modelaudio_transcript_ready","waitms","ajax","url","method","cache","error","setTimeout","success","data","textStatus","xhr","status","load","do_transcription_complete"],"mappings":"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"}