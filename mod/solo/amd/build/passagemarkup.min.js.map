{"version":3,"sources":["../src/passagemarkup.js"],"names":["define","$","log","popoverhelper","debug","controls","currentmode","constants","REVIEWMODE_NOERRORS","REVIEWMODE_SHOWERRORS","cd","passagecontainer","summarytranscript","summarytranscriptplaceholder","audioplayerclass","wordplayerclass","wordclass","spaceclass","badwordclass","endspaceclass","unreadwordclass","unreadspaceclass","aiunmatched","turnclass","options","endwordnumber","errorwords","activityid","attemptid","sesskey","turns","reviewmode","init","config","theid","configcontrol","get","opts","JSON","parse","value","remove","register_controls","totalwordcount","length","totalseconds","sessionscore","sessionmatches","aidata","transcriptwords","transcript","split","filter","el","markup_badwords","markup_aiunmatchedwords","markup_aiunmatchedspaces","markup_turns","removeClass","addClass","thespace","register_events","init_popoverhelper","wordplayer","audioplayer","eachword","eachspace","endwordmarker","that","on","wordnumber","parseInt","attr","isShowing","doPlaySpotCheck","hasClass","chunk","fetchTranscriptChunk","addTranscript","spotcheckindex","playchain","fetchWordPlayChain","theplayer","pad","duration","endtime","parseFloat","audioend","isNaN","starttime","audiostart","currentTime","off","currenttime","pause","play","fetchTurnEndWord","currentwordindex","currentword","turnendword","siblings","last","turnend","fetchTurnStartWord","turnstartword","first","turnstart","isbad","isunmatched","fetchBadWordPlayChain","startword","endword","audiostartword","audioendword","startindex","endindex","passageendword","beforelimit","afterlimit","startadjust","endadjust","console","doSpotCheckMode","spotcheckmode","prevmatch","each","index","unmatchedcount","errorword","undoSpotCheckMode","doTranscriptCheckMode","undoTranscriptCheckMode","checkindex","transcriptlength","startpassageindex","isunreadword","tposition","endpassageindex","ret","slice","join","trim","m","processunread","turnspan","startelement","start","newturnspan","insertBefore","i","end","append","processspace","processscores","enforcemarker"],"mappings":"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","sourcesContent":["define(['jquery', 'core/log', 'mod_solo/popoverhelper'], function ($, log, popoverhelper) {\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Passage Markup: initialising');\n\n    return {\n        //controls\n\n        controls: {},\n        currentmode: 'grading',\n\n        constants: {\n            REVIEWMODE_NOERRORS: 0,\n            REVIEWMODE_SHOWERRORS: 1\n        },\n\n        //class definitions\n        cd: {\n            passagecontainer: 'mod_solo_grading_passagecont',\n            summarytranscript: 'mod_solo_summarytranscript',\n            summarytranscriptplaceholder: 'mod_solo_summarytranscriptplaceholder',\n            audioplayerclass: 'mod_solo_passageaudioplayer',\n            wordplayerclass: 'mod_solo_hidden_player',\n            wordclass: 'mod_solo_grading_passageword',\n            spaceclass: 'mod_solo_grading_passagespace',\n            badwordclass: 'mod_solo_grading_badword',\n            endspaceclass: 'mod_solo_grading_endspace',\n            unreadwordclass: 'mod_solo_grading_unreadword',\n            unreadspaceclass: 'mod_solo_grading_unreadspace',\n            aiunmatched: 'mod_solo_aiunmatched',\n            turnclass: 'summarytranscriptpart'\n        },\n\n        options: {\n            endwordnumber: 0,\n            errorwords: {},\n            activityid: null,\n            attemptid: null,\n            sesskey: null,\n            turns: [],\n            reviewmode: 1 //this.constants.REVIEWMODE_SHOWERRORS\n        },\n\n\n        init: function (config) {\n\n            //pick up opts from html\n            var theid = '#' + config['id'];\n            var configcontrol = $(theid).get(0);\n            if (configcontrol) {\n                var opts = JSON.parse(configcontrol.value);\n                $(theid).remove();\n            } else {\n                //if there is no config we might as well give up\n                log.debug('Passage Markup js: No config found on page. Giving up.');\n                return;\n            }\n\n            //register the controls\n            this.register_controls();\n\n            //stash important info\n            this.options.activityid = opts['activityid'];\n            this.options.attemptid = opts['attemptid'];\n            this.options.sesskey = opts['sesskey'];\n            this.options.turns = opts['turns'];\n            this.options.totalwordcount = $('.' + this.cd.wordclass).length;\n\n            if (opts['sessiontime'] > 0) {\n                if (opts['sessionerrors'] !== '') {\n                    this.options.errorwords = JSON.parse(opts['sessionerrors']);\n                } else {\n                    this.options.errorwords = {};\n                }\n                this.options.totalseconds = opts['sessiontime'];\n                this.options.endwordnumber = opts['sessionendword'];\n                this.options.sessionscore = opts['sessionscore'];\n\n\n                //We may have session matches and AI data, if AI is turned on\n                if(opts['sessionmatches']) {\n                    this.options.sessionmatches = JSON.parse(opts['sessionmatches']);\n                }else{\n                    this.options.sessionmatches =[];\n                }\n                this.options.aidata = opts['aidata'];\n                if (this.options.aidata) {\n                    this.options.transcriptwords = opts['aidata'].transcript.split(\" \");\n\n                    //remove empty elements ... these can get in there\n                    this.options.transcriptwords = this.options.transcriptwords.filter(function (el) {\n                        return el !== '';\n                    });\n\n                } else {\n                    this.options.transcriptwords = [];\n                }\n\n                //if we have the AI data then visually, and internally mark up the mismatches\n                this.markup_badwords();\n                this.markup_aiunmatchedwords();\n                this.markup_aiunmatchedspaces();\n\n                //mark up turns\n                this.markup_turns();\n\n                //display passage turns nicely\n                $('.' + this.cd.passagecontainer).removeClass(this.cd.summarytranscriptplaceholder).addClass(this.cd.summarytranscript);\n\n\n            } else {\n                //set up our end passage marker\n                this.options.endwordnumber = this.options.totalwordcount;\n            }\n\n            //add the endword marker\n            var thespace = $('#' + this.cd.spaceclass + '_' + this.options.endwordnumber);\n            thespace.addClass(this.cd.endspaceclass);\n\n            //register events\n            this.register_events();\n\n\n            //init our popover helper which sets up the button events\n            this.init_popoverhelper();\n\n        },\n\n        //set up events related to popover helper\n        init_popoverhelper: function () {\n            var that = this;\n\n            //init the popover now that we have set the correct callback event handling thingies\n            popoverhelper.init();\n        },\n\n        register_controls: function () {\n\n            this.controls.wordplayer = $('#' + this.cd.wordplayerclass);\n            this.controls.audioplayer = $('#' + this.cd.audioplayerclass);\n            this.controls.eachword = $('.' + this.cd.wordclass);\n            this.controls.eachspace = $('.' + this.cd.spaceclass);\n            this.controls.endwordmarker = $('#' + this.cd.spaceclass + '_' + this.options.endwordnumber);\n            this.controls.passagecontainer = $(\".\" + this.cd.passagecontainer);\n\n        },\n\n        register_events: function () {\n            var that = this;\n            //set up event handlers\n\n\n            //Play audio from and to spot check part\n            this.controls.passagecontainer.on('click','.' + this.cd.wordclass, function () {\n                    var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                    //some clicks are opening popup, some are playing and some are closing popups\n                    //dont play when closing popups\n                    if (!popoverhelper.isShowing(this)) {\n                        that.doPlaySpotCheck(wordnumber);\n                    }\n\n                    if($(this).hasClass(that.cd.aiunmatched)){\n                        var chunk = that.fetchTranscriptChunk(wordnumber);\n                        if (chunk) {\n                            popoverhelper.addTranscript(this, chunk);\n                        }\n                    }\n\n            });\n\n        },\n\n\n        /*\n        * Here we fetch the playchain, start playing frm audiostart and add an event handler to stop at audioend\n         */\n        doPlaySpotCheck: function (spotcheckindex) {\n            var playchain = this.fetchWordPlayChain(spotcheckindex);\n            log.debug(playchain);\n            var theplayer = this.controls.audioplayer[0];\n            //we pad the play audio by 0.5 seconds beginning and end\n            var pad = 0.5;\n            var duration = theplayer.duration;\n            //determine starttime\n            var endtime = parseFloat(playchain.audioend);\n            if (!isNaN(duration) && duration > (endtime + pad)) {\n                endtime = endtime + pad;\n            }\n            //determine endtime\n            var starttime = parseFloat(playchain.audiostart);\n            if ((starttime - pad) > 0) {\n                starttime = starttime - pad;\n            }\n\n            theplayer.currentTime = starttime;\n            $(this.controls.audioplayer).off(\"timeupdate\");\n            $(this.controls.audioplayer).on(\"timeupdate\", function (e) {\n                var currenttime = theplayer.currentTime;\n                if (currenttime >= endtime) {\n                    $(this).off(\"timeupdate\");\n                    theplayer.pause();\n                }\n            });\n            theplayer.play();\n        },\n\n\n        fetchTurnEndWord: function(currentwordindex){\n            var currentword = $('#' + this.cd.wordclass + '_' + currentwordindex);\n            var turnendword = currentword.siblings('.' + this.cd.wordclass).last();\n            var turnend = turnendword.attr('data-wordnumber');\n            if(!turnend || turnend < currentwordindex ){\n                turnend = currentwordindex;\n            }\n            return turnend;\n\n        },\n\n        fetchTurnStartWord: function(currentwordindex){\n            var currentword = $('#' + this.cd.wordclass + '_' + currentwordindex);\n            var turnstartword = currentword.siblings('.' + this.cd.wordclass).first();\n            var turnstart = turnstartword.attr('data-wordnumber');\n            if(!turnstart || turnstart >currentwordindex ){\n                turnstart = currentwordindex;\n            }\n            return turnstart;\n\n        },\n\n\n        /*\n        * The playchain is all the words in a string of badwords.\n        * The complexity comes because a bad word  is usually one that isunmatched by AI.\n         */\n        fetchWordPlayChain: function (wordnumber) {\n            var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n            var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n            if(isbad || isunmatched){\n                return this.fetchBadWordPlayChain(wordnumber);\n            }else{\n                var starttime = this.options.sessionmatches['' + wordnumber].audiostart;\n                var endtime = this.options.sessionmatches['' + wordnumber].audioend;\n                var playchain = {};\n                playchain.startword = wordnumber;\n                playchain.endword = wordnumber;\n                playchain.audiostart = starttime;\n                playchain.audioend = endtime;\n                return playchain;\n            }\n        },\n\n        /*\n        * The playchain is all the words in a string of badwords.\n        * The complexity comes because a bad word  is usually one that isunmatched by AI.\n        * So if the teacher clicks on a passage word that did not appear in the transcript, what should we play?\n        * Answer: All the words from the last known to the next known word. Hence we create a play chain\n        * For consistency, if the teacher flags matched words as bad, while we do know their precise location we still\n        * make a play chain. Its not a common situation probably.\n         */\n        fetchBadWordPlayChain: function (spotcheckindex) {\n\n            //The session matched words we use to get the audiostart and end\n            var audiostartword=0;\n            var audioendword=0;\n\n            //find startword\n            var startindex = spotcheckindex;\n            var starttime = -1;\n            for (var wordnumber = spotcheckindex; wordnumber > 0; wordnumber--) {\n                var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if current wordnumber part of the playchain, set it as the startindex.\n                // And get the audiotime if its a matched word. (we only know audiotime of matched words)\n                if (isbad || isunmatched) {\n                    startindex = wordnumber;\n                    if (!isunmatched) {\n                        starttime = this.options.sessionmatches['' + wordnumber].audiostart;\n                        audiostartword=wordnumber;\n                    } else {\n                        starttime = -1;\n                    }\n                } else {\n                    break;\n                }\n            }//end of for loop --\n            //if we have no starttime then we need to get the next matched word's audioend and use that\n            if (starttime === -1) {\n                starttime = 0;\n                for (var wordnumber = startindex - 1; wordnumber > 0; wordnumber--) {\n                    if (this.options.sessionmatches['' + wordnumber]) {\n                        starttime = this.options.sessionmatches['' + wordnumber].audioend;\n                        audiostartword=wordnumber;\n                        break;\n                    }\n                }\n            }\n\n            //find endword\n            var endindex = spotcheckindex;\n            var endtime = -1;\n            var passageendword = this.options.totalwordcount;\n            for (var wordnumber = spotcheckindex; wordnumber <= passageendword; wordnumber++) {\n                var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if its part of the playchain, set it to startindex. And get time if its a matched word.\n                if (isbad || isunmatched) {\n                    endindex = wordnumber;\n                    if (!isunmatched) {\n                        endtime = this.options.sessionmatches['' + wordnumber].audioend;\n                        audioendword=wordnumber;\n                    } else {\n                        endtime = -1;\n                    }\n                } else {\n                    break;\n                }\n            }//end of for loop --\n            //if we have no endtime then we need to get the next matched word's audiostart and use that\n            if (endtime === -1) {\n                endtime = this.options.totalseconds;\n                for (var wordnumber = endindex + 1; wordnumber <= passageendword; wordnumber++) {\n                    if (this.options.sessionmatches['' + wordnumber]) {\n                        endtime = this.options.sessionmatches['' + wordnumber].audiostart;\n                        audioendword=wordnumber;\n                        break;\n                    }\n                }\n            }\n\n            //work out the playchain\n            var playchain = {};\n            playchain.startword = startindex;\n            playchain.endword = parseInt(endindex);\n            playchain.audiostart = starttime;\n            playchain.audioend = parseInt(endtime);\n            //console.log('audiostart:' + starttime);\n            //console.log('audioend:' + endtime);\n\n            //here we adjust the playback if we have gone out of the turn\n            //its totally black magic guesswork, but it works ok\n            var turnstart = this.fetchTurnStartWord(spotcheckindex);\n            var turnend = this.fetchTurnEndWord(spotcheckindex);\n            var beforelimit =0;\n            var afterlimit =0;\n            var startadjust =0;\n            var endadjust =0;\n            if(audiostartword > 0 && audiostartword < turnstart){\n                beforelimit = spotcheckindex-turnstart + 1;\n            }\n            if(audioendword > turnend){\n                afterlimit = turnend -spotcheckindex+ 1;\n            }\n            //no point trying to guess a completely mismatched turn.\n            if(beforelimit && afterlimit){\n                //give up ... what a disaster\n            }else {\n                //if the start is out of the turn\n                if (beforelimit) {\n                    startadjust = 0.5 * beforelimit;\n                    playchain.audiostart = playchain.audioend - startadjust;\n                    console.log('startadjust:' + startadjust);\n\n                    //if the end is out of the turn\n                } else if (afterlimit) {\n                    endadjust = 0.7 * afterlimit;\n                    playchain.audioend = playchain.audiostart + endadjust;\n                    console.log('endadjust:' + startadjust);\n                }\n            }\n            console.log(playchain);\n            return playchain;\n\n        },\n\n        /*\n        * Here we mark up the passage for spotcheck mode. This will make up the spaces and the words as either badwords\n        * or aiunmatched words. We need to create playchains so aiunmatched still is indeicated visibly even where its\n        * not a badword (ie has been corrected)\n         */\n        doSpotCheckMode: function () {\n            var that = this;\n\n            //mark up all ai unmatched words as aiunmatched\n            this.markup_aiunmatchedwords();\n\n            //mark up all badwords as spotcheck words\n            $('.' + this.cd.badwordclass).addClass(this.cd.spotcheckmode);\n\n            //mark up spaces between spotcheck word and spotcheck/aiunmatched word (bad spaces)\n            //this.markup_badspaces();\n\n            //mark up spaces between aiunmatched word and spotcheck/aiunmatched word (aiunmatched spaces)\n            this.markup_aiunmatchedspaces();\n\n            this.currentmode = \"spotcheck\";\n        },\n\n        //mark up all ai unmatched words as aiunmatched\n        markup_aiunmatchedwords: function () {\n            var that = this;\n            if (this.options.sessionmatches) {\n                var prevmatch = 0;\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var unmatchedcount = index - prevmatch - 1;\n                    if (unmatchedcount > 0) {\n                        for (var errorword = 1; errorword < unmatchedcount + 1; errorword++) {\n                            var wordnumber = prevmatch + errorword;\n                            $('#' + that.cd.wordclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                        }\n                    }\n                    prevmatch = parseInt(index);\n                });\n\n                //mark all words from last matched word to the end as aiunmatched\n                for (var errorword = prevmatch + 1; errorword <= this.options.endwordnumber; errorword++) {\n                    $('#' + that.cd.wordclass + '_' + errorword).addClass(that.cd.aiunmatched);\n                }\n            }\n\n        },\n\n\n\n        markup_aiunmatchedspaces: function () {\n            var that = this;\n            $('.' + this.cd.wordclass + '.' + this.cd.aiunmatched).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.spotcheckmode) ||\n                    $('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                }\n            });\n        },\n\n\n        undoSpotCheckMode: function () {\n            $('.' + this.cd.badwordclass).removeClass(this.cd.spotcheckmode);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.spotcheckmode);\n            $('.' + this.cd.wordclass).removeClass(this.cd.aiunmatched);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.aiunmatched);\n            $(this.controls.audioplayer).off(\"timeupdate\");\n            popoverhelper.remove();\n        },\n\n        /*\n       * Here we mark up the passage for transcriptcheck mode.\n        */\n        doTranscriptCheckMode: function () {\n            var that = this;\n            //mark up all ai unmatched words as transcriptcheck\n            if (this.options.sessionmatches) {\n                var prevmatch = 0;\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var unmatchedcount = index - prevmatch - 1;\n                    if (unmatchedcount > 0) {\n                        for (var errorword = 1; errorword < unmatchedcount + 1; errorword++) {\n                            var wordnumber = prevmatch + errorword;\n                            $('#' + that.cd.wordclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                        }\n                    }\n                    prevmatch = parseInt(index);\n                });\n\n                //mark all words from last matched word to the end as aiunmatched\n                for (var errorword = prevmatch + 1; errorword <= this.options.endwordnumber; errorword++) {\n                    $('#' + that.cd.wordclass + '_' + errorword).addClass(that.cd.aiunmatched);\n                }\n            }\n\n            //mark up spaces between aiunmatched word and aiunmatched (bad spaces)\n            $('.' + this.cd.aiunmatched).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                }\n            });\n\n            this.currentmode = \"transcriptcheck\";\n        },\n\n        undoTranscriptCheckMode: function () {\n            $('.' + this.cd.wordclass).removeClass(this.cd.aiunmatched);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.aiunmatched);\n   //         popoverhelper.remove();\n        },\n\n\n        /*\n       * This will take a wordindex and find the previous and next transcript indexes that were matched and\n       * return all the transcript words in between those.\n        */\n        fetchTranscriptChunk: function (checkindex) {\n\n            var transcriptlength = this.options.transcriptwords.length;\n            if (transcriptlength === 0) {\n                return \"\";\n            }\n\n            //find startindex\n            var startindex = -1;\n            var startpassageindex=-1;\n            for (var wordnumber = checkindex; wordnumber > 0; wordnumber--) {\n\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                var isunreadword = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.unreadwordclass);\n                //if we matched then the subsequent transcript word is the last unmatched one in the checkindex sequence\n                if (!isunmatched && !isunreadword) {\n                    startindex = this.options.sessionmatches['' + wordnumber].tposition + 1;\n                    var startpassageindex=wordnumber;\n                    break;\n                }\n            }//end of for loop\n\n            //find endindex\n            var endindex = -1;\n            var endpassageindex=-1;\n            for (var wordnumber = checkindex; wordnumber <= transcriptlength; wordnumber++) {\n\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if we matched then the previous transcript word is the last unmatched one in the checkindex sequence\n                if (!isunmatched) {\n                    endindex = this.options.sessionmatches['' + wordnumber].tposition - 1;\n                    endpassageindex=wordnumber;\n                    break;\n                }\n            }//end of for loop --\n\n            //if there was no previous matched word, we set start to 1\n            if (startindex === -1) {\n                startindex = 1;\n            }\n            //if there was no subsequent matched word we flag the end as the -1\n            if (endindex === transcriptlength) {\n                endindex = -1;\n                //an edge case is where the first word is not in transcript and first match is the second or later passage\n                //word. It might not be possible for endindex to be lower than start index, but we don't want it anyway\n            } else if (endindex === 0 || endindex < startindex) {\n                return false;\n            }\n\n            //here we check if we have gone out of the turn\n            var turnstart = this.fetchTurnStartWord(checkindex);\n            var turnend = this.fetchTurnEndWord(checkindex);\n            var beforelimit =0;\n            var afterlimit =0;\n            if(startpassageindex < turnstart){\n                var beforelimit = checkindex-turnstart + 1;\n            }\n            if(endpassageindex > turnend ||endpassageindex ==-1){\n                var afterlimit = turnend -checkindex+ 1;\n            }\n            //no point trying to guess a completely mismatched turn.\n            if(beforelimit && afterlimit){\n                return false;\n            }\n            //if the start is out of the turn\n            if(beforelimit){\n                startindex = endindex -beforelimit;\n                if(startindex<1){return false;}\n                //if the end is out of the turn\n            }else if(afterlimit){\n                endindex = startindex +afterlimit;\n                if(endindex>+transcriptlength){return false;}\n            }\n\n            //up until this point the indexes have started from 1, since the passage word numbers start from 1\n            //but the transcript array is 0 based so we adjust. array splice function does not include item and endindex\n            ///so it needs to be one more then start index. hence we do not adjust that\n            startindex--;\n\n            //finally we return the section\n            var ret = false;\n            if (endindex > 0) {\n                ret = this.options.transcriptwords.slice(startindex, endindex).join(\" \");\n            } else {\n                ret = this.options.transcriptwords.slice(startindex).join(\" \");\n            }\n            if (ret.trim() === '') {\n                return false;\n            } else {\n                return ret;\n            }\n        },\n\n        markup_badwords: function () {\n            var m = this;\n            this.processunread();\n            if (this.options.reviewmode == this.constants.REVIEWMODE_SHOWERRORS) {\n                $.each(m.options.errorwords, function (index) {\n                        $('#' + m.cd.wordclass + '_' + m.options.errorwords[index].wordnumber).addClass(m.cd.badwordclass);\n                    }\n                );\n            }\n        },\n\n        markup_turns: function() {\n            var m= this;\n            var turnspan ='<span class=\"' + m.cd.turnclass + '\"></span>';\n            $.each(m.options.turns, function (index) {\n                   var startelement = $('#' + m.cd.wordclass + '_' + m.options.turns[index].start);\n                   var newturnspan  = $(turnspan).insertBefore(startelement);;\n                   for(var i=m.options.turns[index].start; i<=m.options.turns[index].end;i++) {\n                       newturnspan.append($('#' + m.cd.wordclass + '_' + i));\n                       newturnspan.append($('#' + m.cd.spaceclass + '_' + i));\n                   }\n                }\n            );\n        },\n\n\n        //this function is never called it seems ....\n        processspace: function () {\n            //this event is entered by  click on space\n            //it relies on attr data-wordnumber being set correctly\n            var m = this;\n            var wordnumber = $(this).attr('data-wordnumber');\n            var thespace = $('#' + m.cd.spaceclass + '_' + wordnumber);\n\n            if (wordnumber === m.options.endwordnumber) {\n                m.options.endwordnumber = m.options.totalwordcount;\n                thespace.removeClass(m.cd.endspaceclass);\n                $('#' + m.cd.spaceclass + '_' + m.options.totalwordcount).addClass(m.cd.endspaceclass);\n            } else {\n                $('#' + m.cd.spaceclass + '_' + m.options.endwordnumber).removeClass(m.cd.endspaceclass);\n                m.options.endwordnumber = wordnumber;\n                thespace.addClass(m.cd.endspaceclass);\n            }\n            m.processunread();\n            m.processscores();\n        },\n\n        processunread: function () {\n            var m = this;\n            m.controls.eachword.each(function (index) {\n                var wordnumber = $(this).attr('data-wordnumber');\n                var thespace = $('#' + m.cd.spaceclass + '_' + wordnumber);\n\n                if (Number(wordnumber) > Number(m.options.endwordnumber)) {\n                    $(this).addClass(m.cd.unreadwordclass);\n                    thespace.addClass(m.cd.unreadspaceclass);\n\n                    //this will clear badwords after the endmarker\n                    if (m.options.enforcemarker && wordnumber in m.options.errorwords) {\n                        delete m.options.errorwords[wordnumber];\n                        $(this).removeClass(m.cd.badwordclass);\n                    }\n                } else {\n                    $(this).removeClass(m.cd.unreadwordclass);\n                    thespace.removeClass(m.cd.unreadspaceclass);\n                }\n            });\n        }\n    };\n});"],"file":"passagemarkup.min.js"}