{"version":3,"file":"passagemarkup.min.js","sources":["../src/passagemarkup.js"],"sourcesContent":["define(['jquery', 'core/log', 'mod_solo/popoverhelper'], function ($, log, popoverhelper) {\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Passage Markup: initialising');\n\n    return {\n        //controls\n\n        controls: {},\n        currentmode: 'grading',\n\n        constants: {\n            REVIEWMODE_NOERRORS: 0,\n            REVIEWMODE_SHOWERRORS: 1\n        },\n\n        //class definitions\n        cd: {\n            passagecontainer: 'mod_solo_grading_passagecont',\n            summarytranscript: 'mod_solo_summarytranscript',\n            summarytranscriptplaceholder: 'mod_solo_summarytranscriptplaceholder',\n            audioplayerclass: 'mod_solo_passageaudioplayer',\n            wordplayerclass: 'mod_solo_hidden_player',\n            wordclass: 'mod_solo_grading_passageword',\n            spaceclass: 'mod_solo_grading_passagespace',\n            badwordclass: 'mod_solo_grading_badword',\n            endspaceclass: 'mod_solo_grading_endspace',\n            unreadwordclass: 'mod_solo_grading_unreadword',\n            unreadspaceclass: 'mod_solo_grading_unreadspace',\n            aiunmatched: 'mod_solo_aiunmatched',\n            turnclass: 'summarytranscriptpart'\n        },\n\n        options: {\n            endwordnumber: 0,\n            errorwords: {},\n            activityid: null,\n            attemptid: null,\n            sesskey: null,\n            turns: [],\n            reviewmode: 1 //this.constants.REVIEWMODE_SHOWERRORS\n        },\n\n\n        init: function (config) {\n\n            //pick up opts from html\n            var theid = '#' + config['id'];\n            var configcontrol = $(theid).get(0);\n            if (configcontrol) {\n                var opts = JSON.parse(configcontrol.value);\n                $(theid).remove();\n            } else {\n                //if there is no config we might as well give up\n                log.debug('Passage Markup js: No config found on page. Giving up.');\n                return;\n            }\n\n            //register the controls\n            this.register_controls();\n\n            //stash important info\n            this.options.activityid = opts['activityid'];\n            this.options.attemptid = opts['attemptid'];\n            this.options.sesskey = opts['sesskey'];\n            this.options.turns = opts['turns'];\n            this.options.totalwordcount = $('.' + this.cd.wordclass).length;\n\n            if (opts['sessiontime'] > 0) {\n                if (opts['sessionerrors'] !== '') {\n                    this.options.errorwords = JSON.parse(opts['sessionerrors']);\n                } else {\n                    this.options.errorwords = {};\n                }\n                this.options.totalseconds = opts['sessiontime'];\n                this.options.endwordnumber = opts['sessionendword'];\n                this.options.sessionscore = opts['sessionscore'];\n\n\n                //We may have session matches and AI data, if AI is turned on\n                if(opts['sessionmatches']) {\n                    this.options.sessionmatches = JSON.parse(opts['sessionmatches']);\n                }else{\n                    this.options.sessionmatches =[];\n                }\n                this.options.aidata = opts['aidata'];\n                if (this.options.aidata) {\n                    this.options.transcriptwords = opts['aidata'].transcript.split(\" \");\n\n                    //remove empty elements ... these can get in there\n                    this.options.transcriptwords = this.options.transcriptwords.filter(function (el) {\n                        return el !== '';\n                    });\n\n                } else {\n                    this.options.transcriptwords = [];\n                }\n\n                //if we have the AI data then visually, and internally mark up the mismatches\n                this.markup_badwords();\n                this.markup_aiunmatchedwords();\n                this.markup_aiunmatchedspaces();\n\n                //mark up turns\n                this.markup_turns();\n\n                //display passage turns nicely\n                $('.' + this.cd.passagecontainer).removeClass(this.cd.summarytranscriptplaceholder).addClass(this.cd.summarytranscript);\n\n\n            } else {\n                //set up our end passage marker\n                this.options.endwordnumber = this.options.totalwordcount;\n            }\n\n            //add the endword marker\n            var thespace = $('#' + this.cd.spaceclass + '_' + this.options.endwordnumber);\n            thespace.addClass(this.cd.endspaceclass);\n\n            //register events\n            this.register_events();\n\n\n            //init our popover helper which sets up the button events\n            this.init_popoverhelper();\n\n        },\n\n        //set up events related to popover helper\n        init_popoverhelper: function () {\n            var that = this;\n\n            //init the popover now that we have set the correct callback event handling thingies\n            popoverhelper.init();\n        },\n\n        register_controls: function () {\n\n            this.controls.wordplayer = $('#' + this.cd.wordplayerclass);\n            this.controls.audioplayer = $('#' + this.cd.audioplayerclass);\n            this.controls.eachword = $('.' + this.cd.wordclass);\n            this.controls.eachspace = $('.' + this.cd.spaceclass);\n            this.controls.endwordmarker = $('#' + this.cd.spaceclass + '_' + this.options.endwordnumber);\n            this.controls.passagecontainer = $(\".\" + this.cd.passagecontainer);\n\n        },\n\n        register_events: function () {\n            var that = this;\n            //set up event handlers\n\n\n            //Play audio from and to spot check part\n            this.controls.passagecontainer.on('click','.' + this.cd.wordclass, function () {\n                    var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                    //some clicks are opening popup, some are playing and some are closing popups\n                    //dont play when closing popups\n                    if (!popoverhelper.isShowing(this)) {\n                        that.doPlaySpotCheck(wordnumber);\n                    }\n\n                    if($(this).hasClass(that.cd.aiunmatched)){\n                        var chunk = that.fetchTranscriptChunk(wordnumber);\n                        if (chunk) {\n                            popoverhelper.addTranscript(this, chunk);\n                        }\n                    }\n\n            });\n\n        },\n\n\n        /*\n        * Here we fetch the playchain, start playing frm audiostart and add an event handler to stop at audioend\n         */\n        doPlaySpotCheck: function (spotcheckindex) {\n            var playchain = this.fetchWordPlayChain(spotcheckindex);\n            log.debug(playchain);\n            var theplayer = this.controls.audioplayer[0];\n            //we pad the play audio by 0.5 seconds beginning and end\n            var pad = 0.5;\n            var duration = theplayer.duration;\n            //determine starttime\n            var endtime = parseFloat(playchain.audioend);\n            if (!isNaN(duration) && duration > (endtime + pad)) {\n                endtime = endtime + pad;\n            }\n            //determine endtime\n            var starttime = parseFloat(playchain.audiostart);\n            if ((starttime - pad) > 0) {\n                starttime = starttime - pad;\n            }\n\n            theplayer.currentTime = starttime;\n            $(this.controls.audioplayer).off(\"timeupdate\");\n            $(this.controls.audioplayer).on(\"timeupdate\", function (e) {\n                var currenttime = theplayer.currentTime;\n                if (currenttime >= endtime) {\n                    $(this).off(\"timeupdate\");\n                    theplayer.pause();\n                }\n            });\n            theplayer.play();\n        },\n\n\n        fetchTurnEndWord: function(currentwordindex){\n            var currentword = $('#' + this.cd.wordclass + '_' + currentwordindex);\n            var turnendword = currentword.siblings('.' + this.cd.wordclass).last();\n            var turnend = turnendword.attr('data-wordnumber');\n            if(!turnend || turnend < currentwordindex ){\n                turnend = currentwordindex;\n            }\n            return turnend;\n\n        },\n\n        fetchTurnStartWord: function(currentwordindex){\n            var currentword = $('#' + this.cd.wordclass + '_' + currentwordindex);\n            var turnstartword = currentword.siblings('.' + this.cd.wordclass).first();\n            var turnstart = turnstartword.attr('data-wordnumber');\n            if(!turnstart || turnstart >currentwordindex ){\n                turnstart = currentwordindex;\n            }\n            return turnstart;\n\n        },\n\n\n        /*\n        * The playchain is all the words in a string of badwords.\n        * The complexity comes because a bad word  is usually one that isunmatched by AI.\n         */\n        fetchWordPlayChain: function (wordnumber) {\n            var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n            var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n            if(isbad || isunmatched){\n                return this.fetchBadWordPlayChain(wordnumber);\n            }else{\n                var starttime = this.options.sessionmatches['' + wordnumber].audiostart;\n                var endtime = this.options.sessionmatches['' + wordnumber].audioend;\n                var playchain = {};\n                playchain.startword = wordnumber;\n                playchain.endword = wordnumber;\n                playchain.audiostart = starttime;\n                playchain.audioend = endtime;\n                return playchain;\n            }\n        },\n\n        /*\n        * The playchain is all the words in a string of badwords.\n        * The complexity comes because a bad word  is usually one that isunmatched by AI.\n        * So if the teacher clicks on a passage word that did not appear in the transcript, what should we play?\n        * Answer: All the words from the last known to the next known word. Hence we create a play chain\n        * For consistency, if the teacher flags matched words as bad, while we do know their precise location we still\n        * make a play chain. Its not a common situation probably.\n         */\n        fetchBadWordPlayChain: function (spotcheckindex) {\n\n            //The session matched words we use to get the audiostart and end\n            var audiostartword=0;\n            var audioendword=0;\n\n            //find startword\n            var startindex = spotcheckindex;\n            var starttime = -1;\n            for (var wordnumber = spotcheckindex; wordnumber > 0; wordnumber--) {\n                var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if current wordnumber part of the playchain, set it as the startindex.\n                // And get the audiotime if its a matched word. (we only know audiotime of matched words)\n                if (isbad || isunmatched) {\n                    startindex = wordnumber;\n                    if (!isunmatched) {\n                        starttime = this.options.sessionmatches['' + wordnumber].audiostart;\n                        audiostartword=wordnumber;\n                    } else {\n                        starttime = -1;\n                    }\n                } else {\n                    break;\n                }\n            }//end of for loop --\n            //if we have no starttime then we need to get the next matched word's audioend and use that\n            if (starttime === -1) {\n                starttime = 0;\n                for (var wordnumber = startindex - 1; wordnumber > 0; wordnumber--) {\n                    if (this.options.sessionmatches['' + wordnumber]) {\n                        starttime = this.options.sessionmatches['' + wordnumber].audioend;\n                        audiostartword=wordnumber;\n                        break;\n                    }\n                }\n            }\n\n            //find endword\n            var endindex = spotcheckindex;\n            var endtime = -1;\n            var passageendword = this.options.totalwordcount;\n            for (var wordnumber = spotcheckindex; wordnumber <= passageendword; wordnumber++) {\n                var isbad = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.badwordclass);\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if its part of the playchain, set it to startindex. And get time if its a matched word.\n                if (isbad || isunmatched) {\n                    endindex = wordnumber;\n                    if (!isunmatched) {\n                        endtime = this.options.sessionmatches['' + wordnumber].audioend;\n                        audioendword=wordnumber;\n                    } else {\n                        endtime = -1;\n                    }\n                } else {\n                    break;\n                }\n            }//end of for loop --\n            //if we have no endtime then we need to get the next matched word's audiostart and use that\n            if (endtime === -1) {\n                endtime = this.options.totalseconds;\n                for (var wordnumber = endindex + 1; wordnumber <= passageendword; wordnumber++) {\n                    if (this.options.sessionmatches['' + wordnumber]) {\n                        endtime = this.options.sessionmatches['' + wordnumber].audiostart;\n                        audioendword=wordnumber;\n                        break;\n                    }\n                }\n            }\n\n            //work out the playchain\n            var playchain = {};\n            playchain.startword = startindex;\n            playchain.endword = parseInt(endindex);\n            playchain.audiostart = starttime;\n            playchain.audioend = parseInt(endtime);\n            //console.log('audiostart:' + starttime);\n            //console.log('audioend:' + endtime);\n\n            //here we adjust the playback if we have gone out of the turn\n            //its totally black magic guesswork, but it works ok\n            var turnstart = this.fetchTurnStartWord(spotcheckindex);\n            var turnend = this.fetchTurnEndWord(spotcheckindex);\n            var beforelimit =0;\n            var afterlimit =0;\n            var startadjust =0;\n            var endadjust =0;\n            if(audiostartword > 0 && audiostartword < turnstart){\n                beforelimit = spotcheckindex-turnstart + 1;\n            }\n            if(audioendword > turnend){\n                afterlimit = turnend -spotcheckindex+ 1;\n            }\n            //no point trying to guess a completely mismatched turn.\n            if(beforelimit && afterlimit){\n                //give up ... what a disaster\n            }else {\n                //if the start is out of the turn\n                if (beforelimit) {\n                    startadjust = 0.5 * beforelimit;\n                    playchain.audiostart = playchain.audioend - startadjust;\n                    console.log('startadjust:' + startadjust);\n\n                    //if the end is out of the turn\n                } else if (afterlimit) {\n                    endadjust = 0.7 * afterlimit;\n                    playchain.audioend = playchain.audiostart + endadjust;\n                    console.log('endadjust:' + startadjust);\n                }\n            }\n            console.log(playchain);\n            return playchain;\n\n        },\n\n        /*\n        * Here we mark up the passage for spotcheck mode. This will make up the spaces and the words as either badwords\n        * or aiunmatched words. We need to create playchains so aiunmatched still is indeicated visibly even where its\n        * not a badword (ie has been corrected)\n         */\n        doSpotCheckMode: function () {\n            var that = this;\n\n            //mark up all ai unmatched words as aiunmatched\n            this.markup_aiunmatchedwords();\n\n            //mark up all badwords as spotcheck words\n            $('.' + this.cd.badwordclass).addClass(this.cd.spotcheckmode);\n\n            //mark up spaces between spotcheck word and spotcheck/aiunmatched word (bad spaces)\n            //this.markup_badspaces();\n\n            //mark up spaces between aiunmatched word and spotcheck/aiunmatched word (aiunmatched spaces)\n            this.markup_aiunmatchedspaces();\n\n            this.currentmode = \"spotcheck\";\n        },\n\n        //mark up all ai unmatched words as aiunmatched\n        markup_aiunmatchedwords: function () {\n            var that = this;\n            if (this.options.sessionmatches) {\n                var prevmatch = 0;\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var unmatchedcount = index - prevmatch - 1;\n                    if (unmatchedcount > 0) {\n                        for (var errorword = 1; errorword < unmatchedcount + 1; errorword++) {\n                            var wordnumber = prevmatch + errorword;\n                            $('#' + that.cd.wordclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                        }\n                    }\n                    prevmatch = parseInt(index);\n                });\n\n                //mark all words from last matched word to the end as aiunmatched\n                for (var errorword = prevmatch + 1; errorword <= this.options.endwordnumber; errorword++) {\n                    $('#' + that.cd.wordclass + '_' + errorword).addClass(that.cd.aiunmatched);\n                }\n            }\n\n        },\n\n\n\n        markup_aiunmatchedspaces: function () {\n            var that = this;\n            $('.' + this.cd.wordclass + '.' + this.cd.aiunmatched).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.spotcheckmode) ||\n                    $('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                }\n            });\n        },\n\n\n        undoSpotCheckMode: function () {\n            $('.' + this.cd.badwordclass).removeClass(this.cd.spotcheckmode);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.spotcheckmode);\n            $('.' + this.cd.wordclass).removeClass(this.cd.aiunmatched);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.aiunmatched);\n            $(this.controls.audioplayer).off(\"timeupdate\");\n            popoverhelper.remove();\n        },\n\n        /*\n       * Here we mark up the passage for transcriptcheck mode.\n        */\n        doTranscriptCheckMode: function () {\n            var that = this;\n            //mark up all ai unmatched words as transcriptcheck\n            if (this.options.sessionmatches) {\n                var prevmatch = 0;\n                $.each(this.options.sessionmatches, function (index, match) {\n                    var unmatchedcount = index - prevmatch - 1;\n                    if (unmatchedcount > 0) {\n                        for (var errorword = 1; errorword < unmatchedcount + 1; errorword++) {\n                            var wordnumber = prevmatch + errorword;\n                            $('#' + that.cd.wordclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                        }\n                    }\n                    prevmatch = parseInt(index);\n                });\n\n                //mark all words from last matched word to the end as aiunmatched\n                for (var errorword = prevmatch + 1; errorword <= this.options.endwordnumber; errorword++) {\n                    $('#' + that.cd.wordclass + '_' + errorword).addClass(that.cd.aiunmatched);\n                }\n            }\n\n            //mark up spaces between aiunmatched word and aiunmatched (bad spaces)\n            $('.' + this.cd.aiunmatched).each(function (index) {\n                var wordnumber = parseInt($(this).attr('data-wordnumber'));\n                //build chains (highlight spaces) of badwords or aiunmatched\n                if ($('#' + that.cd.wordclass + '_' + (wordnumber + 1)).hasClass(that.cd.aiunmatched)) {\n                    $('#' + that.cd.spaceclass + '_' + wordnumber).addClass(that.cd.aiunmatched);\n                }\n            });\n\n            this.currentmode = \"transcriptcheck\";\n        },\n\n        undoTranscriptCheckMode: function () {\n            $('.' + this.cd.wordclass).removeClass(this.cd.aiunmatched);\n            $('.' + this.cd.spaceclass).removeClass(this.cd.aiunmatched);\n   //         popoverhelper.remove();\n        },\n\n\n        /*\n       * This will take a wordindex and find the previous and next transcript indexes that were matched and\n       * return all the transcript words in between those.\n        */\n        fetchTranscriptChunk: function (checkindex) {\n\n            var transcriptlength = this.options.transcriptwords.length;\n            if (transcriptlength === 0) {\n                return \"\";\n            }\n\n            //find startindex\n            var startindex = -1;\n            var startpassageindex=-1;\n            for (var wordnumber = checkindex; wordnumber > 0; wordnumber--) {\n\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                var isunreadword = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.unreadwordclass);\n                //if we matched then the subsequent transcript word is the last unmatched one in the checkindex sequence\n                if (!isunmatched && !isunreadword) {\n                    startindex = this.options.sessionmatches['' + wordnumber].tposition + 1;\n                    var startpassageindex=wordnumber;\n                    break;\n                }\n            }//end of for loop\n\n            //find endindex\n            var endindex = -1;\n            var endpassageindex=-1;\n            for (var wordnumber = checkindex; wordnumber <= transcriptlength; wordnumber++) {\n\n                var isunmatched = $('#' + this.cd.wordclass + '_' + wordnumber).hasClass(this.cd.aiunmatched);\n                //if we matched then the previous transcript word is the last unmatched one in the checkindex sequence\n                if (!isunmatched) {\n                    endindex = this.options.sessionmatches['' + wordnumber].tposition - 1;\n                    endpassageindex=wordnumber;\n                    break;\n                }\n            }//end of for loop --\n\n            //if there was no previous matched word, we set start to 1\n            if (startindex === -1) {\n                startindex = 1;\n            }\n            //if there was no subsequent matched word we flag the end as the -1\n            if (endindex === transcriptlength) {\n                endindex = -1;\n                //an edge case is where the first word is not in transcript and first match is the second or later passage\n                //word. It might not be possible for endindex to be lower than start index, but we don't want it anyway\n            } else if (endindex === 0 || endindex < startindex) {\n                return false;\n            }\n\n            //here we check if we have gone out of the turn\n            var turnstart = this.fetchTurnStartWord(checkindex);\n            var turnend = this.fetchTurnEndWord(checkindex);\n            var beforelimit =0;\n            var afterlimit =0;\n            if(startpassageindex < turnstart){\n                var beforelimit = checkindex-turnstart + 1;\n            }\n            if(endpassageindex > turnend ||endpassageindex ==-1){\n                var afterlimit = turnend -checkindex+ 1;\n            }\n            //no point trying to guess a completely mismatched turn.\n            if(beforelimit && afterlimit){\n                return false;\n            }\n            //if the start is out of the turn\n            if(beforelimit){\n                startindex = endindex -beforelimit;\n                if(startindex<1){return false;}\n                //if the end is out of the turn\n            }else if(afterlimit){\n                endindex = startindex +afterlimit;\n                if(endindex>+transcriptlength){return false;}\n            }\n\n            //up until this point the indexes have started from 1, since the passage word numbers start from 1\n            //but the transcript array is 0 based so we adjust. array splice function does not include item and endindex\n            ///so it needs to be one more then start index. hence we do not adjust that\n            startindex--;\n\n            //finally we return the section\n            var ret = false;\n            if (endindex > 0) {\n                ret = this.options.transcriptwords.slice(startindex, endindex).join(\" \");\n            } else {\n                ret = this.options.transcriptwords.slice(startindex).join(\" \");\n            }\n            if (ret.trim() === '') {\n                return false;\n            } else {\n                return ret;\n            }\n        },\n\n        markup_badwords: function () {\n            var m = this;\n            this.processunread();\n            if (this.options.reviewmode == this.constants.REVIEWMODE_SHOWERRORS) {\n                $.each(m.options.errorwords, function (index) {\n                        $('#' + m.cd.wordclass + '_' + m.options.errorwords[index].wordnumber).addClass(m.cd.badwordclass);\n                    }\n                );\n            }\n        },\n\n        markup_turns: function() {\n            var m= this;\n            var turnspan ='<span class=\"' + m.cd.turnclass + '\"></span>';\n            $.each(m.options.turns, function (index) {\n                   var startelement = $('#' + m.cd.wordclass + '_' + m.options.turns[index].start);\n                   var newturnspan  = $(turnspan).insertBefore(startelement);;\n                   for(var i=m.options.turns[index].start; i<=m.options.turns[index].end;i++) {\n                       newturnspan.append($('#' + m.cd.wordclass + '_' + i));\n                       newturnspan.append($('#' + m.cd.spaceclass + '_' + i));\n                   }\n                }\n            );\n        },\n\n\n        //this function is never called it seems ....\n        processspace: function () {\n            //this event is entered by  click on space\n            //it relies on attr data-wordnumber being set correctly\n            var m = this;\n            var wordnumber = $(this).attr('data-wordnumber');\n            var thespace = $('#' + m.cd.spaceclass + '_' + wordnumber);\n\n            if (wordnumber === m.options.endwordnumber) {\n                m.options.endwordnumber = m.options.totalwordcount;\n                thespace.removeClass(m.cd.endspaceclass);\n                $('#' + m.cd.spaceclass + '_' + m.options.totalwordcount).addClass(m.cd.endspaceclass);\n            } else {\n                $('#' + m.cd.spaceclass + '_' + m.options.endwordnumber).removeClass(m.cd.endspaceclass);\n                m.options.endwordnumber = wordnumber;\n                thespace.addClass(m.cd.endspaceclass);\n            }\n            m.processunread();\n            m.processscores();\n        },\n\n        processunread: function () {\n            var m = this;\n            m.controls.eachword.each(function (index) {\n                var wordnumber = $(this).attr('data-wordnumber');\n                var thespace = $('#' + m.cd.spaceclass + '_' + wordnumber);\n\n                if (Number(wordnumber) > Number(m.options.endwordnumber)) {\n                    $(this).addClass(m.cd.unreadwordclass);\n                    thespace.addClass(m.cd.unreadspaceclass);\n\n                    //this will clear badwords after the endmarker\n                    if (m.options.enforcemarker && wordnumber in m.options.errorwords) {\n                        delete m.options.errorwords[wordnumber];\n                        $(this).removeClass(m.cd.badwordclass);\n                    }\n                } else {\n                    $(this).removeClass(m.cd.unreadwordclass);\n                    thespace.removeClass(m.cd.unreadspaceclass);\n                }\n            });\n        }\n    };\n});"],"names":["define","$","log","popoverhelper","debug","controls","currentmode","constants","REVIEWMODE_NOERRORS","REVIEWMODE_SHOWERRORS","cd","passagecontainer","summarytranscript","summarytranscriptplaceholder","audioplayerclass","wordplayerclass","wordclass","spaceclass","badwordclass","endspaceclass","unreadwordclass","unreadspaceclass","aiunmatched","turnclass","options","endwordnumber","errorwords","activityid","attemptid","sesskey","turns","reviewmode","init","config","theid","configcontrol","get","opts","JSON","parse","value","remove","register_controls","totalwordcount","this","length","totalseconds","sessionscore","sessionmatches","aidata","transcriptwords","transcript","split","filter","el","markup_badwords","markup_aiunmatchedwords","markup_aiunmatchedspaces","markup_turns","removeClass","addClass","register_events","init_popoverhelper","wordplayer","audioplayer","eachword","eachspace","endwordmarker","that","on","wordnumber","parseInt","attr","isShowing","doPlaySpotCheck","hasClass","chunk","fetchTranscriptChunk","addTranscript","spotcheckindex","playchain","fetchWordPlayChain","theplayer","duration","endtime","parseFloat","audioend","isNaN","starttime","audiostart","currentTime","off","e","pause","play","fetchTurnEndWord","currentwordindex","turnend","siblings","last","fetchTurnStartWord","turnstart","first","isbad","isunmatched","fetchBadWordPlayChain","startword","endword","audiostartword","audioendword","startindex","endindex","passageendword","beforelimit","afterlimit","startadjust","endadjust","console","doSpotCheckMode","spotcheckmode","prevmatch","each","index","match","unmatchedcount","errorword","undoSpotCheckMode","doTranscriptCheckMode","undoTranscriptCheckMode","checkindex","transcriptlength","startpassageindex","isunreadword","tposition","endpassageindex","ret","slice","join","trim","m","processunread","turnspan","startelement","start","newturnspan","insertBefore","i","end","append","processspace","thespace","processscores","Number","enforcemarker"],"mappings":"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"}