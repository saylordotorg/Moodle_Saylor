{"version":3,"file":"speech_browser.min.js","sources":["../src/speech_browser.js"],"sourcesContent":["/* jshint ignore:start */\ndefine(['jquery', 'core/log'], function ($, log) {\n\n    \"use strict\"; // jshint ;_;\n\n    log.debug('speech_browser: initialising');\n\n    return {\n\n        recognition: null,\n        recognizing: false,\n        ignore_onend: false,\n        final_transcript: '',\n        start_timestamp: 0,\n        lang: 'en-US',\n\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        will_work_ok: function(opts){\n            var brave = typeof navigator.brave !== 'undefined';\n            if(brave){return false;}\n\n            var edge = navigator.userAgent.toLowerCase().indexOf(\"edg/\") > -1;\n            if(edge){return false;}\n\n            return ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n        },\n\n        init: function (opts) {\n            var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;\n            this.recognition = new SpeechRecognition();\n            this.recognition.continuous = true;\n            this.recognition.interimResults = true;\n            this.lang = opts.language ? opts.language : 'en-US';\n\n            this.register_events();\n        },\n\n        set_grammar: function (grammar) {\n            var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList;\n            if (SpeechGrammarList) {\n                var speechRecognitionList = new SpeechGrammarList();\n                speechRecognitionList.addFromString(grammar, 1);\n                this.recognition.grammars = speechRecognitionList;\n            }\n        },\n\n        start: function (stream) {\n            //browser recognition does not actually need to the stream\n            if (this.recognizing) {\n                return;\n            }\n            this.recognizing = true;\n            this.final_transcript = '';\n            this.recognition.lang = this.lang;//select_dialect.value;\n            this.recognition.start();\n            this.ignore_onend = false;\n            this.start_timestamp = Date.now();//event.timeStamp;\n\n        },\n        stop: function () {\n            // if (this.recognizing) {\n            this.recognizing = false;\n            this.recognition.stop();\n            return;\n            //}\n        },\n\n        register_events: function () {\n\n            var recognition = this.recognition;\n            var that = this;\n\n            recognition.onstart = function () {\n                that.recognizing = true;\n\n            };\n            recognition.onerror = function (event) {\n                if (event.error == 'no-speech') {\n                    log.debug('info_no_speech');\n                    that.ignore_onend = true;\n                }\n                if (event.error == 'audio-capture') {\n                    log.debug('info_no_microphone');\n                    that.ignore_onend = true;\n                }\n                if (event.error == 'not-allowed') {\n                    if (event.timeStamp - that.start_timestamp < 100) {\n                        log.debug('info_blocked');\n                    } else {\n                        log.debug('info_denied');\n                    }\n                    that.ignore_onend = true;\n                }\n            };\n            recognition.onend = function () {\n                //that.recognizing = false;\n\n                // we restart by default\n                // we might need to be more clever here\n                if (that.recognizing == false) {\n                    return;\n                }\n                if (that.ignore_onend) {\n                    that.recognizing = false;\n                } else {\n                    recognition.start();\n                }\n\n            };\n            recognition.onresult = function (event) {\n                var interim_transcript = '';\n                for (var i = event.resultIndex; i < event.results.length; ++i) {\n                    if (event.results[i].isFinal) {\n                        that.final_transcript += event.results[i][0].transcript;\n                        that.onfinalspeechcapture(that.final_transcript,JSON.stringify(event.results));\n                        that.final_transcript = '';\n                    } else {\n                        interim_transcript += event.results[i][0].transcript;\n                        that.oninterimspeechcapture(interim_transcript);\n                    }\n                }\n\n\n            };\n        },//end of register events\n\n        onfinalspeechcapture: function (speechtext,speechresults) {\n            log.debug(speechtext);\n        },\n        oninterimspeechcapture: function (speechtext) {\n            // log.debug(speechtext);\n        }\n\n    };//end of returned object\n});//total end\n"],"names":["define","$","log","debug","recognition","recognizing","ignore_onend","final_transcript","start_timestamp","lang","clone","extend","this","will_work_ok","opts","navigator","brave","userAgent","toLowerCase","indexOf","window","init","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","language","register_events","set_grammar","grammar","SpeechGrammarList","webkitSpeechGrammarList","speechRecognitionList","addFromString","grammars","start","stream","Date","now","stop","that","onstart","onerror","event","error","timeStamp","onend","onresult","interim_transcript","i","resultIndex","results","length","isFinal","transcript","onfinalspeechcapture","JSON","stringify","oninterimspeechcapture","speechtext","speechresults"],"mappings":"AACAA,sCAAO,CAAC,SAAU,aAAa,SAAUC,EAAGC,YAIxCA,IAAIC,MAAM,gCAEH,CAEHC,YAAa,KACbC,aAAa,EACbC,cAAc,EACdC,iBAAkB,GAClBC,gBAAiB,EACjBC,KAAM,QAINC,MAAO,kBACIT,EAAEU,QAAO,EAAM,GAAIC,OAG9BC,aAAc,SAASC,kBACoB,IAApBC,UAAUC,UAGlBD,UAAUE,UAAUC,cAAcC,QAAQ,SAAW,KAGxD,4BAA6BC,QAAU,sBAAuBA,UAG1EC,KAAM,SAAUP,UACRQ,kBAAoBA,mBAAqBC,6BACxCnB,YAAc,IAAIkB,uBAClBlB,YAAYoB,YAAa,OACzBpB,YAAYqB,gBAAiB,OAC7BhB,KAAOK,KAAKY,SAAWZ,KAAKY,SAAW,aAEvCC,mBAGTC,YAAa,SAAUC,aACfC,kBAAoBA,mBAAqBC,2BACzCD,kBAAmB,KACfE,sBAAwB,IAAIF,kBAChCE,sBAAsBC,cAAcJ,QAAS,QACxCzB,YAAY8B,SAAWF,wBAIpCG,MAAO,SAAUC,QAETxB,KAAKP,mBAGJA,aAAc,OACdE,iBAAmB,QACnBH,YAAYK,KAAOG,KAAKH,UACxBL,YAAY+B,aACZ7B,cAAe,OACfE,gBAAkB6B,KAAKC,QAGhCC,KAAM,gBAEGlC,aAAc,OACdD,YAAYmC,QAKrBZ,gBAAiB,eAETvB,YAAcQ,KAAKR,YACnBoC,KAAO5B,KAEXR,YAAYqC,QAAU,WAClBD,KAAKnC,aAAc,GAGvBD,YAAYsC,QAAU,SAAUC,OACT,aAAfA,MAAMC,QACN1C,IAAIC,MAAM,kBACVqC,KAAKlC,cAAe,GAEL,iBAAfqC,MAAMC,QACN1C,IAAIC,MAAM,sBACVqC,KAAKlC,cAAe,GAEL,eAAfqC,MAAMC,QACFD,MAAME,UAAYL,KAAKhC,gBAAkB,IACzCN,IAAIC,MAAM,gBAEVD,IAAIC,MAAM,eAEdqC,KAAKlC,cAAe,IAG5BF,YAAY0C,MAAQ,WAKQ,GAApBN,KAAKnC,cAGLmC,KAAKlC,aACLkC,KAAKnC,aAAc,EAEnBD,YAAY+B,UAIpB/B,YAAY2C,SAAW,SAAUJ,eACzBK,mBAAqB,GAChBC,EAAIN,MAAMO,YAAaD,EAAIN,MAAMQ,QAAQC,SAAUH,EACpDN,MAAMQ,QAAQF,GAAGI,SACjBb,KAAKjC,kBAAoBoC,MAAMQ,QAAQF,GAAG,GAAGK,WAC7Cd,KAAKe,qBAAqBf,KAAKjC,iBAAiBiD,KAAKC,UAAUd,MAAMQ,UACrEX,KAAKjC,iBAAmB,KAExByC,oBAAsBL,MAAMQ,QAAQF,GAAG,GAAGK,WAC1Cd,KAAKkB,uBAAuBV,uBAQ5CO,qBAAsB,SAAUI,WAAWC,eACvC1D,IAAIC,MAAMwD,aAEdD,uBAAwB,SAAUC"}