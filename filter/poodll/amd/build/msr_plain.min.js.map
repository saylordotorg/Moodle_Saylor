{"version":3,"sources":["../src/msr_plain.js"],"names":["define","$","log","utils","debug","timeout","mediaRecorder","mediaStream","audioctx","msr","mediaType","audioBitsPerSecond","videoBitsPerSecond","clone","extend","init","start","timeSlice","that","getVideoTracks","length","getAudioTracks","stream","navigator","mozGetUserMedia","MediaStream","addTrack","mimeType","MediaRecorder","isTypeSupported","audiotypes","i","themimetype","is_chrome","rec_options","videotypes","e","ignoreMutedMedia","ondataavailable","data","size","blob","onerror","error","name","state","stop","audioInput","createMediaStreamSource","connect","audioanalyser","core","pause","resume","clearRecordedData","isMediaStreamActive","active","ended","looper","setTimeout"],"mappings":"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","sourcesContent":["/* jshint ignore:start */\ndefine(['jquery',\n        'core/log', 'filter_poodll/utils_amd'],\n    function ($, log, utils) {\n\n        \"use strict\"; // jshint ;_;\n\n        log.debug('PoodLL Plain Recorder: initialising');\n\n        return {\n            timeout: 0,\n            mediaRecorder: null,\n            mediaStream: null,\n            audioctx: null, //unused\n            msr: null,\n            mediaType: null,\n            //Firefox fails to calc properly at 128000, and blobs concatenate at about 1/4 the correct length\n            //its a hack to get us over the broken firefox but 12800 works.\n            audioBitsPerSecond: 12800,\n            videoBitsPerSecond: 2500000,\n\n\n            //for making multiple instances\n            clone: function () {\n                return $.extend(true, {}, this);\n            },\n\n            // init the recorder\n            init: function (msr, mediaStream, audioctx, mediaType) {\n                this.msr = msr;\n                this.mediaStream = mediaStream;\n                this.audioctx = audioctx; //unused\n                this.mediaType = mediaType;\n            },\n\n            /**\n             * This method records MediaStream.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.record();\n             */\n            start: function (timeSlice, __disableLogs) {\n                var that = this;\n\n\n                if (this.mediaType === 'audio') {\n                    //this section can probably be removed. I can not see a need for it.\n                    if (this.mediaStream.getVideoTracks().length && this.mediaStream.getAudioTracks().length) {\n                        log.debug('Somehow we got a video stream, paring it down to just audio. ');\n                        var stream;\n                        if (!!navigator.mozGetUserMedia) {\n                            stream = new MediaStream();\n                            stream.addTrack(this.mediaStream.getAudioTracks()[0]);\n                        } else {\n                            // webkitMediaStream\n                            stream = new MediaStream(this.mediaStream.getAudioTracks());\n                        }\n                        this.mediaStream = stream;\n                    }\n                }\n\n                //lets work out our mime type\n                this.mimeType=false;\n                //if audio\n                if(this.mediaType==='audio') {\n                    //if its a mediarecorder and does not support 'isTypeSupported' ..it can only be Safari ..\n                    if (!MediaRecorder.isTypeSupported) {\n                        this.mimeType = \"audio/mp4\";\n                    }else {\n                        var audiotypes = ['ogg', 'webm', 'quicktime', 'mp4', 'm4a', 'wav'];\n                        for (var i = 0; i < audiotypes.length; i++) {\n                            var themimetype = 'audio/' + audiotypes[i];\n                            if (MediaRecorder.isTypeSupported(themimetype)) {\n                                this.mimeType = themimetype;\n                                break;\n                            }\n                        }\n                        //we make an intelligent choice if required to do so\n                        if (this.mimeType === false) {\n                            this.mimeType = utils.is_chrome() ? 'audio/webm' : 'audio/ogg';\n                        }\n                    }\n                    var rec_options = {\n                        //videoBitsPerSecond : this.videoBitsPerSecond,\n                        audioBitsPerSecond: this.audioBitsPerSecond, //Firefox needs this\n                        mimeType: this.mimeType\n                    };\n\n                //else video\n                }else{\n                    //if its a mediarecorder and does not support 'isTypeSupported' ..it can only be Safari ..\n                    if (!MediaRecorder.isTypeSupported) {\n                        this.mimeType = \"video/mp4\";\n                    }else {\n                        var videotypes = ['webm', 'ogv', 'quicktime', 'mp4', 'mpeg'];\n                        for (var i = 0; i < videotypes.length; i++) {\n                            var themimetype = 'video/' + videotypes[i];\n                            if (MediaRecorder.isTypeSupported(themimetype)) {\n                                this.mimeType = themimetype;\n                                break;\n                            }\n                        }\n                        //we make an \"intelligent\" choice if required to do so\n                        if (this.mimeType === false) {\n                            this.mimeType = 'video/webm';\n                        }\n                    }\n\n                    var rec_options = {\n                        //videoBitsPerSecond : this.videoBitsPerSecond,\n                        //audioBitsPerSecond: this.audioBitsPerSecond,\n                        mimeType: this.mimeType\n                    };\n                }\n\n\n                try {\n                    this.mediaRecorder = new MediaRecorder(this.mediaStream, rec_options);\n                } catch (e) {\n                    // if a NON_supported rec_option got us here\n                    // or if Firefox on Android\n                    this.mediaRecorder = new MediaRecorder(this.mediaStream);\n                    log.debug('MediaRecorder API seems unable to record mimeType:' + this.mimeType);\n                }\n                log.debug(\"msr_plain using mime type:\" + this.mimeType);\n\n                // i.e. stop recording when <video> is paused by the user; and auto restart recording\n                // when video is resumed. E.g. yourStream.getVideoTracks()[0].muted = true; // it will auto-stop recording.\n                this.mediaRecorder.ignoreMutedMedia = this.ignoreMutedMedia || false;\n\n\n                // Dispatching OnDataAvailable Handler\n                this.mediaRecorder.ondataavailable = function (e) {\n                    //  log.debug('data available:' + e.data.size );\n                    if (!e.data || !e.data.size) {\n                        return;\n                    }\n\n                    //var blob = new Blob([e.data], {type: that.mimeType});\n                    var blob = e.data; //in firefox this leaves hints about the codec\n                    that.msr.ondataavailable(blob);\n                 //   log.debug('e.data.size:' + e.data);\n                 //   log.debug('abr:' + that.mediaRecorder.audioBitsPerSecond);\n                 //   log.debug('vbr:' + that.mediaRecorder.videoBitsPerSecond);\n\n                };\n\n                this.mediaRecorder.onerror = function (error) {\n                    if (error.name === 'InvalidState') {\n                        log.debug('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.');\n                    } else if (error.name === 'OutOfMemory') {\n                        log.debug('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'IllegalStreamModification') {\n                        log.debug('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'OtherRecordingError') {\n                        log.debug('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'GenericError') {\n                        log.debug('The UA cannot provide the codec or recording option that has been requested.', error);\n                    } else {\n                        log.debug('MediaRecorder Error', error);\n                    }\n\n                    // When the stream is \"ended\" set recording to 'inactive'\n                    // and stop gathering data. Callers should not rely on\n                    // exactness of the timeSlice value, especially\n                    // if the timeSlice value is small. Callers should\n                    // consider timeSlice as a minimum value\n\n                    if (!!that.mediaRecorder && that.mediaRecorder.state !== 'inactive' && that.mediaRecorder.state !== 'stopped') {\n                        that.mediaRecorder.stop();\n                    }\n                };\n\n                //We need a source node to connect the analyser to. The analyser is for visualisations\n                var audioInput = this.audioctx.createMediaStreamSource(this.mediaStream);\n                audioInput.connect(this.msr.audioanalyser.core);\n\n                // void start(optional long mTimeSlice)\n                // The interval of passing encoded data from EncodedBufferCache to onDataAvailable\n                // handler. \"mTimeSlice < 0\" means Session object does not push encoded data to\n                // onDataAvailable, instead, it passive wait the client side pull encoded data\n                // by calling requestData API.\n                try {\n                    that.mediaRecorder.start(timeSlice);\n                } catch (e) {\n                    that.mediaRecorder = null;\n                }\n\n//end of start\n            },\n\n            /**\n             * This method stops recording MediaStream.\n             * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n             */\n            stop: function (callback) {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.mediaRecorder.state === 'recording') {\n                    this.mediaRecorder.stop();\n                }\n            },\n\n            /**\n             * This method pauses the recording process.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.pause();\n             */\n            pause: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.mediaRecorder.state === 'recording') {\n                    this.mediaRecorder.pause();\n                }\n            },\n\n            /**\n             * This method resumes the recording process.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.resume();\n             */\n            resume: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n                if (this.mediaRecorder.state === 'paused') {\n                    this.mediaRecorder.resume();\n                }\n            },\n\n            /**\n             * This method resets currently recorded data.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.clearRecordedData();\n             */\n            clearRecordedData: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                this.pause();\n\n                this.stop();\n            },\n\n            // Reference to \"MediaRecorder\" object\n            //  var mediaRecorder;\n\n            isMediaStreamActive: function () {\n                if ('active' in this.mediaStream) {\n                    if (!this.mediaStream.active) {\n                        return false;\n                    }\n                } else if ('ended' in this.mediaStream) { // old hack\n                    if (this.mediaStream.ended) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n\n            // this method checks if media stream is stopped\n            // or any track is ended.\n            looper: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.isMediaStreamActive() === false) {\n                    this.stop();\n                    return;\n                }\n\n                setTimeout(this.looper, 1000); // check every second\n            }\n        };// end of returned object\n    });// total end"],"file":"msr_plain.min.js"}