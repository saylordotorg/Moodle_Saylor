{"version":3,"sources":["../src/msr_plain.js"],"names":["define","$","log","utils","debug","timeout","mediaRecorder","mediaStream","audioctx","msr","mediaType","clone","extend","init","start","timeSlice","that","getVideoTracks","length","getAudioTracks","stream","navigator","mozGetUserMedia","MediaStream","addTrack","mimeType","MediaRecorder","isTypeSupported","audiotypes","i","themimetype","is_chrome","videotypes","e","ignoreMutedMedia","ondataavailable","data","size","blob","Blob","type","onerror","error","name","state","stop","audioInput","createMediaStreamSource","connect","audioanalyser","core","pause","resume","clearRecordedData","isMediaStreamActive","active","ended","looper","setTimeout"],"mappings":"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","sourcesContent":["/* jshint ignore:start */\ndefine(['jquery',\n        'core/log', 'filter_poodll/utils_amd'],\n    function ($, log, utils) {\n\n        \"use strict\"; // jshint ;_;\n\n        log.debug('PoodLL Plain Recorder: initialising');\n\n        return {\n            timeout: 0,\n            mediaRecorder: null,\n            mediaStream: null,\n            audioctx: null, //unused\n            msr: null,\n            mediaType: null,\n\n\n            //for making multiple instances\n            clone: function () {\n                return $.extend(true, {}, this);\n            },\n\n            // init the recorder\n            init: function (msr, mediaStream, audioctx, mediaType) {\n                this.msr = msr;\n                this.mediaStream = mediaStream;\n                this.audioctx = audioctx; //unused\n                this.mediaType = mediaType;\n            },\n\n            /**\n             * This method records MediaStream.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.record();\n             */\n            start: function (timeSlice, __disableLogs) {\n                var that = this;\n\n\n                if (this.mediaType === 'audio') {\n                    if (this.mediaStream.getVideoTracks().length && this.mediaStream.getAudioTracks().length) {\n                        var stream;\n                        if (!!navigator.mozGetUserMedia) {\n                            stream = new MediaStream();\n                            stream.addTrack(this.mediaStream.getAudioTracks()[0]);\n                        } else {\n                            // webkitMediaStream\n                            stream = new MediaStream(this.mediaStream.getAudioTracks());\n                        }\n                        this.mediaStream = stream;\n                    }\n                }\n\n                //lets work out our mime type\n                this.mimeType=false;\n                //if audio\n                if(this.mediaType==='audio') {\n                    //if its a mediarecorder and does not support 'isTypeSupported' ..it can only be Safari ..\n                    if (!MediaRecorder.isTypeSupported) {\n                        this.mimeType = \"audio/mp4\";\n                    }else {\n                        var audiotypes = ['ogg', 'webm', 'quicktime', 'mp4', 'm4a', 'wav'];\n                        for (var i = 0; i < audiotypes.length; i++) {\n                            var themimetype = 'audio/' + audiotypes[i];\n                            if (MediaRecorder.isTypeSupported(themimetype)) {\n                                this.mimeType = themimetype;\n                                break;\n                            }\n                        }\n                        //we make an intelligent choice if required to do so\n                        if (this.mimeType === false) {\n                            this.mimeType = utils.is_chrome() ? 'audio/webm' : 'audio/ogg';\n                        }\n                    }\n                //else video\n                }else{\n                    //if its a mediarecorder and does not support 'isTypeSupported' ..it can only be Safari ..\n                    if (!MediaRecorder.isTypeSupported) {\n                        this.mimeType = \"video/mp4\";\n                    }else {\n                        var videotypes = ['webm', 'ogv', 'quicktime', 'mp4', 'mpeg'];\n                        for (var i = 0; i < videotypes.length; i++) {\n                            var themimetype = 'video/' + videotypes[i];\n                            if (MediaRecorder.isTypeSupported(themimetype)) {\n                                this.mimeType = themimetype;\n                                break;\n                            }\n                        }\n                        //we make an intelligent choice if required to do so\n                        if (this.mimeType === false) {\n                            this.mimeType = 'video/webm';\n                        }\n                    }\n                }\n\n                // http://dxr.mozilla.org/mozilla-central/source/content/media/MediaRecorder.cpp\n                // https://wiki.mozilla.org/Gecko:MediaRecorder\n                // https://dvcs.w3.org/hg/dap/raw-file/default/media-stream-capture/MediaRecorder.html\n\n                // starting a recording session; which will initiate \"Reading Thread\"\n                // \"Reading Thread\" are used to prevent main-thread blocking scenarios\n                try {\n                    this.mediaRecorder = new MediaRecorder(this.mediaStream, {mimeType: this.mimeType });\n                } catch (e) {\n                    // if someone passed NON_supported mimeType\n                    // or if Firefox on Android\n                    this.mediaRecorder = new MediaRecorder(this.mediaStream);\n                    log.debug('MediaRecorder API seems unable to record mimeType:' + this.mimeType);\n                }\n\n                //set the mimetype to whatever the mediarecorder says it is\n                log.debug(\"msr_plain using mime type:\",this.mimeType);\n\n                // i.e. stop recording when <video> is paused by the user; and auto restart recording\n                // when video is resumed. E.g. yourStream.getVideoTracks()[0].muted = true; // it will auto-stop recording.\n                this.mediaRecorder.ignoreMutedMedia = this.ignoreMutedMedia || false;\n\n\n                // Dispatching OnDataAvailable Handler\n                this.mediaRecorder.ondataavailable = function (e) {\n                    //  log.debug('data available:' + e.data.size );\n                    if (!e.data || !e.data.size) {\n                        return;\n                    }\n\n                    var blob = new Blob([e.data], {type: that.mimeType});\n                    that.msr.ondataavailable(blob);\n                };\n\n                this.mediaRecorder.onerror = function (error) {\n                    if (error.name === 'InvalidState') {\n                        log.debug('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.');\n                    } else if (error.name === 'OutOfMemory') {\n                        log.debug('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'IllegalStreamModification') {\n                        log.debug('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'OtherRecordingError') {\n                        log.debug('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.');\n                    } else if (error.name === 'GenericError') {\n                        log.debug('The UA cannot provide the codec or recording option that has been requested.', error);\n                    } else {\n                        log.debug('MediaRecorder Error', error);\n                    }\n\n                    // When the stream is \"ended\" set recording to 'inactive'\n                    // and stop gathering data. Callers should not rely on\n                    // exactness of the timeSlice value, especially\n                    // if the timeSlice value is small. Callers should\n                    // consider timeSlice as a minimum value\n\n                    if (!!that.mediaRecorder && that.mediaRecorder.state !== 'inactive' && that.mediaRecorder.state !== 'stopped') {\n                        that.mediaRecorder.stop();\n                    }\n                };\n\n                //We need a source node to connect the analyser to. The analyser is for visualisations\n                var audioInput = this.audioctx.createMediaStreamSource(this.mediaStream);\n                audioInput.connect(this.msr.audioanalyser.core);\n\n                // void start(optional long mTimeSlice)\n                // The interval of passing encoded data from EncodedBufferCache to onDataAvailable\n                // handler. \"mTimeSlice < 0\" means Session object does not push encoded data to\n                // onDataAvailable, instead, it passive wait the client side pull encoded data\n                // by calling requestData API.\n                try {\n                    that.mediaRecorder.start(timeSlice);\n                } catch (e) {\n                    that.mediaRecorder = null;\n                }\n\n//end of start\n            },\n\n            /**\n             * This method stops recording MediaStream.\n             * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n             */\n            stop: function (callback) {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.mediaRecorder.state === 'recording') {\n                    this.mediaRecorder.stop();\n                }\n            },\n\n            /**\n             * This method pauses the recording process.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.pause();\n             */\n            pause: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.mediaRecorder.state === 'recording') {\n                    this.mediaRecorder.pause();\n                }\n            },\n\n            /**\n             * This method resumes the recording process.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.resume();\n             */\n            resume: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n                if (this.mediaRecorder.state === 'paused') {\n                    this.mediaRecorder.resume();\n                }\n            },\n\n            /**\n             * This method resets currently recorded data.\n             * @method\n             * @memberof MediaStreamRecorder\n             * @example\n             * recorder.clearRecordedData();\n             */\n            clearRecordedData: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                this.pause();\n\n                this.stop();\n            },\n\n            // Reference to \"MediaRecorder\" object\n            //  var mediaRecorder;\n\n            isMediaStreamActive: function () {\n                if ('active' in this.mediaStream) {\n                    if (!this.mediaStream.active) {\n                        return false;\n                    }\n                } else if ('ended' in this.mediaStream) { // old hack\n                    if (this.mediaStream.ended) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n\n            // this method checks if media stream is stopped\n            // or any track is ended.\n            looper: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                if (this.isMediaStreamActive() === false) {\n                    this.stop();\n                    return;\n                }\n\n                setTimeout(this.looper, 1000); // check every second\n            }\n        };// end of returned object\n    });// total end"],"file":"msr_plain.min.js"}