{"version":3,"file":"msr_stereoaudio.min.js","sources":["../src/msr_stereoaudio.js"],"sourcesContent":["/* jshint ignore:start */\ndefine(['jquery',\n        'core/log', 'filter_poodll/msr_helper_stereoaudio'],\n    function ($, log, helper) {\n\n        \"use strict\"; // jshint ;_;\n\n        log.debug('PoodLL Recorder: initialising');\n\n        return {\n            timeout: 0,\n            mediaRecorder: null,\n            mediaStream: null,\n            msr: null,\n            mediaType: 'audio',\n\n            //for making multiple instances\n            clone: function () {\n                return $.extend(true, {}, this);\n            },\n\n            // init the poodll recorder\n            // basically we check the users preferred recorders and if the rec supports the browser\n            init: function (msr, mediaStream, audioctx, mediaType) {\n                this.msr = msr;\n                this.mediaStream = mediaStream;\n                this.audioctx = audioctx;\n                this.mediaType = mediaType;//always audio\n            },\n\n            start: function (timeSlice, audioctx) {\n                //should start be called more than once, bad things could happen, so stop and then start\n                if(this.timeout!==0){\n                    this.stop();\n                }\n\n                timeSlice = timeSlice || 1000;\n                var that = this;\n\n                this.mediaRecorder = helper.clone();\n                this.mediaRecorder.init(this.msr, this.mediaStream, this.audioctx);\n\n                this.mediaRecorder.record();\n\n                this.timeout = setInterval(function () {\n                    that.mediaRecorder.requestData();\n                }, timeSlice);\n            },\n\n            stop: function () {\n                if (this.mediaRecorder) {\n                    this.mediaRecorder.stop();\n                    clearInterval(this.timeout);\n                    this.timeout =0;\n                }\n            },\n            pause: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n\n                this.mediaRecorder.pause();\n            },\n\n            resume: function () {\n                if (!this.mediaRecorder) {\n                    return;\n                }\n                this.mediaRecorder.resume();\n            },\n\n            ondataavailable: function (blob) {\n                log.debug('ondataavailable:' + blob);\n            },\n\n            onstop: function (error) {\n                log.debug(error);\n            }\n        };// end of returned object\n    });// total end\n"],"names":["define","$","log","helper","debug","timeout","mediaRecorder","mediaStream","msr","mediaType","clone","extend","this","init","audioctx","start","timeSlice","stop","that","record","setInterval","requestData","clearInterval","pause","resume","ondataavailable","blob","onstop","error"],"mappings":"AACAA,uCAAO,CAAC,SACA,WAAY,yCAChB,SAAUC,EAAGC,IAAKC,eAIdD,IAAIE,MAAM,iCAEH,CACHC,QAAS,EACTC,cAAe,KACfC,YAAa,KACbC,IAAK,KACLC,UAAW,QAGXC,MAAO,kBACIT,EAAEU,QAAO,EAAM,GAAIC,OAK9BC,KAAM,SAAUL,IAAKD,YAAaO,SAAUL,gBACnCD,IAAMA,SACND,YAAcA,iBACdO,SAAWA,cACXL,UAAYA,WAGrBM,MAAO,SAAUC,UAAWF,UAEN,IAAfF,KAAKP,cACCY,OAGTD,UAAYA,WAAa,QACrBE,KAAON,UAENN,cAAgBH,OAAOO,aACvBJ,cAAcO,KAAKD,KAAKJ,IAAKI,KAAKL,YAAaK,KAAKE,eAEpDR,cAAca,cAEdd,QAAUe,aAAY,WACvBF,KAAKZ,cAAce,gBACpBL,YAGPC,KAAM,WACEL,KAAKN,qBACAA,cAAcW,OACnBK,cAAcV,KAAKP,cACdA,QAAS,IAGtBkB,MAAO,WACEX,KAAKN,oBAILA,cAAciB,SAGvBC,OAAQ,WACCZ,KAAKN,oBAGLA,cAAckB,UAGvBC,gBAAiB,SAAUC,MACvBxB,IAAIE,MAAM,mBAAqBsB,OAGnCC,OAAQ,SAAUC,OACd1B,IAAIE,MAAMwB"}