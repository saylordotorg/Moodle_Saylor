<?php
// This file is part of Stack - http://stack.maths.ed.ac.uk/
//
// Stack is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Stack is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Stack.  If not, see <http://www.gnu.org/licenses/>.

defined('MOODLE_INTERNAL') || die();

// CAS text and related functions.
//
// @copyright  2012 University of Birmingham.
// @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later.

require_once(__DIR__ . '/ast.container.class.php');
require_once(__DIR__ . '/cassession2.class.php');
require_once(__DIR__ . '/castext/autogen/castextparser.class.php');
require_once(__DIR__ . '/castext/block.factory.php');

class stack_cas_text {

    /** @var string Exactly the cas_text entered. */
    private $rawcastext;

    /** @var string This is processed gradually. */
    private $trimmedcastext;

    /** @var string The end result. */
    private $castext;

    /**
     * @var stack_cas_session2 Context in which the castext is evaluated.
     *  Note, this is the place to set any CAS options of STACK_CAS_Maxima_Preferences.
     */
    private $session;

    /**
     * @var array in which the castrings present in the raw castext are presented. Does not include repeated
     *  strings that would be generated due to loops present in the castext nor strings that would be generated by such blocks that
     *  generate strings (none of such exist yet) but does include everything that is visible inside conditional parts.
     */
    private $rawsession = array();

    /** @var bool whether the string is valid. */
    private $valid = null;

    /** @var bool whether this been sent to the CAS yet? Stops re-sending to the CAS. */
    private $instantiated = null;

    /** @var array any error messages to display to the user. */
    private $errors;

    /** @var stack_cas_castext_parsetreenode the root of the parse tree */
    private $parsetreeroot = null;

    /** @var array holds block-handlers for various parse_tree nodes */
    private $blocks = array();

    public function __construct($rawcastext, $session=null, $seed=null) {

        if (!is_string($rawcastext)) {
            throw new stack_exception('stack_cas_text: raw_castext must be a STRING.');
        } else {
            $this->rawcastext   = $rawcastext;
        }

        if (is_a($session, 'stack_cas_session2') || null === $session) {
            $this->session = $session;
        } else {
            throw new stack_exception('stack_cas_text constructor expects $session to be a stack_cas_session2.');
        }

        if (is_int($seed)) {
            $this->seed = $seed;
        } else if ($seed === null) {
            $this->seed = time();
        } else {
            throw new stack_exception('stack_cas_text: $seed must be a number (or null).');
        }
    }

    /**
     * Checks the castext syntax is valid, no missing @'s, $'s etc
     *
     * @access public
     * @return bool
     */
    private function validate() {
        $this->errors = array();

        // Remove any comments from the castext.
        $this->trimmedcastext = stack_utils::remove_comments(str_replace("\n", ' ', $this->rawcastext));

        if (trim($this->trimmedcastext) === '') {
            $this->valid = true;
            return true;
        }

        // Find reasons to invalidate the text...
        $this->valid = true;

        // Check {@...@}'s match.
        $amps = stack_utils::check_bookends($this->trimmedcastext, '{@', '@}');
        if ($amps !== true) {
            if ($amps == 'left') {
                $this->errors[] = stack_string('stackCas_MissingOpenTeXCAS');
            } else {
                $this->errors[] = stack_string('stackCas_MissingClosingTeXCAS');
            }
            $this->valid = false;
        }

        // Check {#...#}'s match.
        $amps = stack_utils::check_bookends($this->trimmedcastext, '{#', '#}');
        if ($amps !== true) {
            if ($amps == 'left') {
                $this->errors[] = stack_string('stackCas_MissingOpenRawCAS');
            } else {
                $this->errors[] = stack_string('stackCas_MissingClosingRawCAS');
            }
            $this->valid = false;
        }

        // Dollars can be protected for use with currency.
        $protected = str_replace('\$', '', $this->trimmedcastext);
        $dollar = stack_utils::check_matching_pairs($protected, '$');
        if ($dollar == false) {
            $this->errors[] = stack_string('stackCas_MissingDollar');
            $this->valid = false;
        }

        $html = stack_utils::check_bookends($this->trimmedcastext, '<html>', '</html>');
        if ($html !== true) {
            // The method check_bookends does not return false.

            $this->valid = false;
            if ($html == 'left') {
                $this->errors[] = stack_string('stackCas_MissingOpenHTML');
            } else {
                $this->errors[] = stack_string('stackCas_MissingCloseHTML');
            }
        }

        $inline = stack_utils::check_bookends($this->trimmedcastext, '\[', '\]');
        if ($inline !== true) {
            // The method check_bookends does not return false.

            $this->valid = false;
            if ($inline == 'left') {
                $this->errors[] = stack_string('stackCas_MissingOpenDisplay');
            } else {
                $this->errors[] = stack_string('stackCas_MissingCloseDisplay');
            }
        }

        $inline = stack_utils::check_bookends($this->trimmedcastext, '\(', '\)');
        if ($inline !== true) {
            // The method check_bookends does not return false.
            $this->valid = false;
            if ($inline == 'left') {
                $this->errors[] = stack_string('stackCas_MissingOpenInline');
            } else {
                $this->errors[] = stack_string('stackCas_MissingCloseInline');
            }
        }

        // Perform validation on the existing session.
        if (null != $this->session) {
            if (!$this->session->get_valid()) {
                $this->valid = false;
                $this->errors[] = $this->session->get_errors();
            }
        }

        // Perform block and casstring validation.
        $parser = new stack_cas_castext_castextparser($this->trimmedcastext);
        $validationsession = new stack_cas_session2(array(), null, $this->seed);
        $arrayform = $parser->match_castext();
        $arrayform = stack_cas_castext_castextparser::normalize($arrayform);
        $arrayform = stack_cas_castext_castextparser::block_conversion($arrayform);

        $validationparsetreeroot = stack_cas_castext_parsetreenode::build_from_nested($arrayform);

        $this->rawsession = array();
        $this->valid = $this->validation_recursion($validationparsetreeroot, $validationsession) && $this->valid;

        if (array_key_exists('errors', $arrayform)) {
            $this->valid = false;
            $this->errors[] = 'PARSE ERROR: '. $arrayform['errors'];
        }

        return $this->valid;
    }

    private function validation_recursion($node, $session) {
        $valid = true;
        $types = castext_block_factory::get_available_types();
        switch ($node->type) {
            case 'castext':
                $iter = $node->firstchild;
                while ($iter !== null) {
                    $valid = $this->validation_recursion($iter, $session) && $valid;
                    $iter = $iter->nextsibling;
                }
                break;
            case 'block':
                $block = null;
                if (array_key_exists($node->get_content(), $types)) {
                    $block = castext_block_factory::make($node->get_content(), $node, $session, $this->seed);
                } else {
                    $this->errors[] = stack_string('stackBlock_unknownBlock') . " '" . $node->get_content() . "'";
                    $valid = false;
                }
                if ($block != null) {
                    $valid = $block->validate($this->errors) && $valid;
                    $iter = $node->firstchild;
                    while ($iter !== null) {
                         $valid = $this->validation_recursion($iter, $session) && $valid;
                         $iter = $iter->nextsibling;
                    }
                    // We could array_merge but the number of added terms is small in all cases.
                    foreach ($block->validate_extract_attributes() as $cs) {
                        $this->rawsession[] = $cs;
                    }
                }
                break;
            case 'rawcasblock':
                $block = castext_block_factory::make('raw', $node, $session, $this->seed);
                $valid = $block->validate($this->errors) && $valid;
                foreach ($block->validate_extract_attributes() as $cs) {
                    $this->rawsession[] = $cs;
                }
                break;
            case 'texcasblock':
                $block = castext_block_factory::make('latex', $node, $session, $this->seed);
                $valid = $block->validate($this->errors) && $valid;
                foreach ($block->validate_extract_attributes() as $cs) {
                    $this->rawsession[] = $cs;
                }
                break;
        }
        return $valid;
    }

    private function first_pass_recursion(&$node, $conditionstack) {
        $blockchildevaluation = false;
        $types = castext_block_factory::get_available_types();
        switch ($node->type) {
            case 'castext':
                $iter = $node->firstchild;
                while ($iter !== null) {
                    $this->first_pass_recursion($iter, $conditionstack);
                    $iter = $iter->nextsibling;
                }
                break;
            case 'block':
                $block = null;
                if (array_key_exists($node->get_content(), $types)) {
                    $block = castext_block_factory::make($node->get_content(), $node, $this->session, $this->seed);
                } else {
                    throw new stack_exception('stack_cas_text: UNKNOWN NODE '.$node->get_content());
                }
                $block->extract_attributes($this->session, $conditionstack);
                $this->blocks[] = $block;
                $newstack = $block->content_evaluation_context($conditionstack);
                if ($newstack === false) {
                    $blockchildevaluation = true;
                } else {
                    $conditionstack = $newstack;
                }
                if (!$blockchildevaluation) {
                    $iter = $node->firstchild;
                    while ($iter !== null) {
                        $this->first_pass_recursion($iter, $conditionstack);
                        $iter = $iter->nextsibling;
                    }
                }
                break;
            case 'rawcasblock':
                $block = castext_block_factory::make('raw', $node, $this->session, $this->seed);
                $block->extract_attributes($this->session, $conditionstack);
                $this->blocks[] = $block;
                break;
            case 'texcasblock':
                $block = castext_block_factory::make('latex', $node, $this->session, $this->seed);
                $block->extract_attributes($this->session, $conditionstack);
                $this->blocks[] = $block;
                break;
        }
    }

    /**
     * This function actually evaluates the castext.
     */
    private function instantiate() {
        if ($this->valid === null) {
            $this->validate();
        }

        // If we fail to complete the instantiation now then it makes little sense
        // to try again.
        $this->instantiated = false;

        if ($this->session == null) {
            $this->session = new stack_cas_session2(array(), null, $this->seed);
        }

        $freshsession = clone $this->session;

        // Initial pass.
        if (stack_cas_castext_castextparser::castext_parsing_required($this->trimmedcastext)) {
            $parser = new stack_cas_castext_castextparser($this->trimmedcastext);
            $arrayform = $parser->match_castext();
            $arrayform = stack_cas_castext_castextparser::normalize($arrayform);
            $arrayform = stack_cas_castext_castextparser::block_conversion($arrayform);
            $this->parsetreeroot = stack_cas_castext_parsetreenode::build_from_nested($arrayform);
            $this->first_pass_recursion($this->parsetreeroot, array());
        }

        if ($this->valid && $this->session->get_valid()) {
            $this->session->instantiate();
        } else {
            $this->valid = false;
            foreach ($this->session->get_session() as $statement) {
                if ($statement->get_valid() !== true) {
                    $this->errors = array_merge($this->errors, $statement->get_errors(true));
                }
            }
            return false;
        }

        // Handle blocks.
        $requiresrerun = false;
        foreach (array_reverse($this->blocks) as $block) {
            $requiresrerun = $block->process_content($this->session) || $requiresrerun;
        }

        while ($requiresrerun) {
            $this->session = clone $freshsession;
            $this->blocks = array();

            $this->trimmedcastext = $this->parsetreeroot->to_string();

            $parser = new stack_cas_castext_castextparser($this->trimmedcastext);
            $arrayform = $parser->match_castext();
            $arrayform = stack_cas_castext_castextparser::normalize($arrayform);
            $arrayform = stack_cas_castext_castextparser::block_conversion($arrayform);
            $this->parsetreeroot = stack_cas_castext_parsetreenode::build_from_nested($arrayform);
            $this->first_pass_recursion($this->parsetreeroot, array());
            if ($this->session->get_valid()) {
                $this->session->instantiate();
            } else {
                $this->valid = false;
                foreach ($this->session->get_session() as $statement) {
                    if ($statement->get_valid() !== true) {
                        $this->errors = array_merge($this->errors, $statement->get_errors(true));
                    }
                }
                return false;
            }

            $requiresrerun = false;
            foreach (array_reverse($this->blocks) as $block) {
                $requiresrerun = $block->process_content($this->session) || $requiresrerun;
            }
        }

        // This is only excecuted on the blocks existing after the last iteration.
        // Others have been cleared from existence through other means.
        foreach ($this->blocks as $block) {
            $block->clear();
        }

        if (trim($this->trimmedcastext) !== '' && $this->parsetreeroot !== null) {
            $this->trimmedcastext = $this->parsetreeroot->to_string();
        }

        $this->castext = $this->trimmedcastext;

        // Another modification. Stops <html> tags from being given $ tags.
        $this->castext = str_replace('<html>', '', $this->castext);
        // Bug occurs when maxima returns <html>tags in output, eg plots or div by 0 errors.
        $this->castext = str_replace('</html>', '', $this->castext);
        $this->latex_tidy();

        $this->instantiated = true;
    }


    /**
     * Tidy up LaTeX commands used in castext which are not interpreted by MathJax.
     */
    private function latex_tidy() {
        // Need to create line breaks in sensible places.
        $this->castext = str_replace('\begin{itemize}', '<ol>', $this->castext);
        $this->castext = str_replace('\end{itemize}', '</ol>', $this->castext);
        $this->castext = str_replace('\begin{enumerate}', '<ul>', $this->castext);
        $this->castext = str_replace('\end{enumerate}', '</ul>', $this->castext);
        $this->castext = str_replace('\item', '<li>', $this->castext);
    }

    public function get_valid() {
        if (null === $this->valid) {
            $this->validate();
        }
        return $this->valid;
    }

    public function get_errors($casdebug=false) {
        if (null === $this->valid) {
            $this->validate();
        }

        // Just in case there have been errors/warnings from the maxima during possible instantiation.
        if (null != $this->session) {
            $err = trim($this->session->get_errors());
            if ($err != '') {
                $this->errors[] = $err;
            }
        }

        $errmsg = '';
        if ($this->errors != array()) {
            $errmsg .= implode(' ', array_unique($this->errors));
        }

        if ('' != trim($errmsg)) {
            $errmsg = '<span class="error">'.stack_string("stackCas_failedValidation").'</span>'.$errmsg;
        }

        if ($casdebug && null !== $this->session) {
            $errmsg .= $this->session->get_debuginfo();
        }

        return $errmsg;
    }

    public function get_variable_usage(array $updatearray = array()): array {
        if (null === $this->valid) {
            $this->validate();
        }
        // Simply ask all the ast_containers in play for the used variables.
        foreach ($this->rawsession as $cs) {
            $updatearray = $cs->get_variable_usage($updatearray);
        }
        return $updatearray;
    }

    public function get_display_castext() {
        if (null === $this->valid) {
            $this->validate();
        }
        if (null === $this->instantiated) {
            $this->instantiate();
        } else if (false === $this->instantiated) {
            return false;
        }
        return $this->castext;
    }

    public function get_session() {
        if (null === $this->valid) {
            $this->validate();
        }
        if (null === $this->instantiated) {
            $this->instantiate();
        } else if (false === $this->instantiated) {
            return false;
        }
        return $this->session;
    }

    public function get_debuginfo() {
        if (null === $this->session) {
            return "Session is NULL. ";
        }
        return $this->session->get_debuginfo();
    }

}
